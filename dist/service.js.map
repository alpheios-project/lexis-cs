{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/v4.js","webpack:///./src/cedict-service/cedict-data.js","webpack:///./src/cedict-service/cedict-storage.js","webpack:///./src/cedict-service/service.js","webpack:///./src/cedict-service/store.js","webpack:///./src/messaging/destinations/destination.js","webpack:///./src/messaging/destinations/window-iframe-destination.js","webpack:///./src/messaging/messages/message.js","webpack:///./src/messaging/messages/response-message.js","webpack:///./src/messaging/messaging-service.js","webpack:///./src/messaging/stored-request.js","webpack:///./src/schemas/cedict.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjCA,UAAU,mBAAO,CAAC,yDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AACA;AACA;AACqE;;AAErE;AACe;AACf;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA,0BAA0B,iFAAa;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sHAAsH,cAAc;AACpI;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,2FAA2F,0BAA0B;AACrH;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA,qDAAqD,uBAAuB,qBAAqB,IAAI;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,QAAQ;AACtE;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA,4EAA4E,sBAAsB,GAAG,MAAM;AAC3G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpVA;AAAA;AAAA;AAAoD;;AAErC;AACf;AACA;AACA;AACA;AACA;AACA,0DAA0D,gCAAgC,wEAAK,UAAU;AACzG;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,yEAAyE,yCAAyC;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C;AACpF,qCAAqC;AACrC,KAAK;AACL;AACA;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACO;AACS;AACvB;AACV;;AAErD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,uFAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E,mBAAmB,uFAAe;AAClC,OAAO,8BAA8B,uFAAe;AACpD,GAAG;AACH,eAAe,uFAAe;AAC9B;AACA;;AAEA;AACA,sBAAsB,+EAAgB,KAAK,oGAAW;AACtD;;AAEA;AACA,qBAAqB,8EAAU,CAAC,kEAAY;AAC5C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAEc,sFAAuB;;;;;;;;;;;;;ACtDtC;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAA6C;AACxG,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,sDAAsD,qBAAqB;AAC3E,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,aAAa,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB,qBAAqB,IAAI;AACtG;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,yBAAyB,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF,KAAK;AACL;;AAEA;AACA;AACA,qBAAqB,YAAY;AACjC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACvLA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AACA;AACA;AACwE;;AAExE;AACe,sCAAsC,sFAAW;AAChE;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,gBAAgB,kCAAkC,KAAK;AACvD,WAAW,OAAO;;AAElB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC4B;;AAE5B;AACe;AACf;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA,4FAA4F,oBAAoB;AAChH;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,8CAAM;;AAEpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACkC;;AAElC;AACe,8BAA8B,mDAAO;AACpD;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,iCAAiC;AACjC;AACA,gBAAgB,mDAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,MAAM;AACnB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,QAAQ;AACvB;AACA;AACA;AACA,uBAAuB,mDAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACyD;AACb;;AAE5C;AACe;AACf;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,SAAS,kEAAe;AACxB;AACA;AACA;;AAEA;AACA,0DAA0D,yBAAyB;AACnF;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,kEAAe;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA,wEAAwE,WAAW;AACnF,4BAA4B,uDAAa;AACzC;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjJA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM","file":"service.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/cedict-service/service.js\");\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","/**\r\n * @module CedictData\r\n */\r\nimport CedictStorage from '@lexisCs/cedict-service/cedict-storage.js'\r\n\r\n/** A class to serve data from CEDICT */\r\nexport default class CedictData {\r\n  /**\r\n   * @param {object} schema - An object that describes a configuration of a CEDICT data object.\r\n   */\r\n  constructor (schema) {\r\n    CedictData.checkSchemaValidity(schema)\r\n    this._schema = schema\r\n\r\n    /**\r\n     * Whether the object is ready to serve data or not.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    this.isReady = false\r\n\r\n    this._storage = null\r\n\r\n    /**\r\n     * If CEDICT be stored in memory this object will hold all its data.\r\n     *\r\n     * @type {{entries: [], meta: {}}}\r\n     */\r\n    this.cedict = {\r\n\r\n      // A dictionary's metadata\r\n      meta: {},\r\n\r\n      metaKey: 1,\r\n\r\n      /**\r\n       * If data is stored in memory `entries` will keep either\r\n       * an array of dictionary records (if no in memory indexes will be employed) or\r\n       * a map of dictionary records (if in memory indexes will be used).\r\n       * If dictionary data will be stored in permanents storage only `entries` will be null\r\n       */\r\n      entries: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `traditionalHeadwordsIdx`\r\n       * will hold a map: Map<traditionalHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      traditionalHeadwordsIdx: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `simplifiedHeadwordsIdx`\r\n       * will hold a map: Map<simplifiedHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      simplifiedHeadwordsIdx: null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the schema supplied has all the necessary information in it.\r\n   * If schema is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} schema - A JSON like schema object.\r\n   */\r\n  static checkSchemaValidity (schema) {\r\n    if (!schema.storage) throw new Error('Storage tree is missing from a schema')\r\n    if (!schema.storage.stores) throw new Error('Stores data is missing from a schema')\r\n    if (!schema.storage.stores.dictionary) throw new Error('Dictionary tree is missing from a schema')\r\n    if (!schema.storage.stores.dictionary.primaryIndex) throw new Error('A primaryIndex tree of a dictionary is missing from a schema')\r\n    if (!schema.storage.stores.dictionary.primaryIndex.hasOwnProperty('keyPath')) throw new Error('A keyPath option of a primaryIndex tree of a dictionary is missing from a schema') // eslint-disable-line no-prototype-builtins\r\n    if (!schema.storage.stores.dictionary.volatileStorage) throw new Error('A volatileStorage tree of a dictionary is missing from a schema')\r\n    if (!schema.storage.stores.dictionary.volatileStorage.hasOwnProperty('enabled')) throw new Error('enabled option of a volatileStorage tree of a dictionary is missing from a schema') // eslint-disable-line no-prototype-builtins\r\n    if (!schema.storage.stores.dictionary.volatileStorage.hasOwnProperty('indexed')) throw new Error('indexed option of a volatileStorage tree of a dictionary is missing from a schema') // eslint-disable-line no-prototype-builtins\r\n    if (!schema.storage.stores.dictionary.permanentStorage) throw new Error('A permanentStorage tree of a dictionary is missing from a schema')\r\n    if (!schema.storage.stores.dictionary.permanentStorage.hasOwnProperty('enabled')) throw new Error('enabled option of a permanentStorage tree of a dictionary is missing from a schema') // eslint-disable-line no-prototype-builtins\r\n    if (!schema.storage.stores.dictionary.permanentStorage.hasOwnProperty('indexed')) throw new Error('indexed option of a permanentStorage tree of a dictionary is missing from a schema') // eslint-disable-line no-prototype-builtins\r\n    if (!schema.data) throw new Error('Date tree is missing from a schema')\r\n    if (!schema.data.version) throw new Error('Data version is missing from a schema')\r\n    if (!schema.data.revision) throw new Error('Data revision is missing from a schema')\r\n    if (!schema.data.recordsCount) throw new Error('Data records count is missing from a schema')\r\n    if (!schema.data.URI) throw new Error('Data URI is missing from a schema')\r\n    if (!schema.data.chunks || schema.data.chunks.length === 0) throw new Error('Data chunks are missing from a schema')\r\n  }\r\n\r\n  /**\r\n   * Initializes a data object.\r\n   *\r\n   * @returns {Promise<undefined> | Promise<Error>} - A promise\r\n   */\r\n  init () {\r\n    return new Promise((resolve, reject) => {\r\n      this._storage = new CedictStorage(this._schema.storage)\r\n      // `storage.connect()` will create a database if it does not exist yet.\r\n      return this._storage.connect()\r\n        .catch((error) => {\r\n          console.error('Connection to storage cannot be established')\r\n          reject(error)\r\n        })\r\n        .then(() => {\r\n          console.info('Connection was established')\r\n          return this.permanentStorageIntegrity()\r\n        })\r\n        .then((storageData) => {\r\n          console.info('Check integrity returned', storageData)\r\n          /*\r\n          Integrity data has been returned successfully which means database structure is OK.\r\n          Let's check if there is a new version of data available on a server.\r\n           */\r\n          if (\r\n            storageData.recordsInMeta !== 1 ||\r\n            storageData.recordsInDictionary !== this._schema.data.recordsCount ||\r\n            storageData.metadata.version !== this._schema.data.version ||\r\n            storageData.metadata.revision !== this._schema.data.revision\r\n          ) {\r\n            throw new Error('Store is outdated')\r\n          }\r\n          console.info(`In-memory storage state is`, this.cedict)\r\n          // Data in storage is fresh so we can read it into memory structures if we have that option enabled\r\n          this.cedict.meta = storageData.metadata\r\n          if (this._schema.storage.stores.dictionary.volatileStorage.enabled) {\r\n            return this._storage.stores.dictionary.getAllEntries()\r\n              .then((entries) => {\r\n                this.populateVolatileStorage(entries)\r\n                console.info(`In-memory storage state after data loading is`, this.cedict)\r\n              }).catch((error) => reject(error))\r\n          }\r\n        })\r\n        .catch((error) => {\r\n          console.info('Integrity check failed, need to recreate a database', error)\r\n          // Data in permanent storage needs to be updated\r\n          console.info('Data needs to be updated')\r\n          return this._storage.destroy()\r\n          // `connect()` will create storage and stores\r\n            .then(() => this._storage.connect())\r\n            .then(() => this.downloadData())\r\n            .then(() => this.writeToStorage())\r\n        })\r\n        .catch((error) => {\r\n          console.info('Cannot download data from server', error)\r\n          reject(error)\r\n        })\r\n        .then(() => {\r\n          this.isReady = true\r\n          console.info('Initialization is completed')\r\n          resolve()\r\n        })\r\n    })\r\n  }\r\n\r\n  static isKnownCharacterForm(characterForm) {\r\n    return Array.from(Object.values(CedictData.characterForms)).includes(characterForm)\r\n  }\r\n\r\n  permanentStorageIntegrity () {\r\n    // Resolves with number of records in both stores\r\n    // Rejects in database is corrupt\r\n    console.info('Checking a database integrity')\r\n    let integrityRequests = [this._storage.stores.meta, this._storage.stores.dictionary].map(store => store.count()) // eslint-disable-line prefer-const\r\n    integrityRequests.push(this._storage.stores.meta.get(this.cedict.metaKey))\r\n    return Promise.all(integrityRequests).then(([recordsInMeta, recordsInDictionary, metadata]) => {\r\n      if (!metadata || metadata.length === 0) throw new Error('Metadata store has no records')\r\n      if (metadata.length > 1) throw new Error('Metadata store has more than one record')\r\n      return { recordsInMeta, recordsInDictionary, metadata: metadata[0] }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records from CEDICT dictionary for one or several Chinese words.\r\n   *\r\n   * @param {[string]} words - An array of Chinese words.\r\n   * @param {string} characterForm - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {object} - Returns an object whose keys are the words requested and values are arrays of CEDICT records\r\n   *          that has those words.\r\n   */\r\n  getWords (words, characterForm) {\r\n    // CedictData object is not prepared to serve this request\r\n    if (!this.isReady) return Promise.reject(new Error('CEDICT data is not ready'))\r\n\r\n    let getAllCharacterForms = true\r\n    // If character form is not specified we will return all records for all character forms\r\n    if (typeof characterForm !== 'undefined') {\r\n      // Some value is provided for a characterForm\r\n      if (!CedictData.isKnownCharacterForm(characterForm)) return Promise.reject(new Error(`Unknown character form \"${characterForm}\"`))\r\n      getAllCharacterForms = false\r\n    }\r\n\r\n    // Nothing to do\r\n    if (!words) return Promise.resolve({})\r\n\r\n    // Always prefer volatile storage to a permanent one\r\n    if (this._schema.storage.stores.dictionary.volatileStorage.enabled) {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          const startTime = Date.now()\r\n          if (getAllCharacterForms) {\r\n            // Return records for all known character forms\r\n            const result = {\r\n              [CedictData.characterForms.SIMPLIFIED]: this._getWordsFromVolatileStorage(words, CedictData.characterForms.SIMPLIFIED),\r\n              [CedictData.characterForms.TRADITIONAL]: this._getWordsFromVolatileStorage(words, CedictData.characterForms.TRADITIONAL)\r\n            }\r\n            console.info(`Request took ${Date.now() - startTime} ms`)\r\n            resolve(result)\r\n          } else {\r\n            // Return records for a specified character set\r\n            const result = {\r\n              [characterForm]: this._getWordsFromVolatileStorage(words, characterForm),\r\n            }\r\n            console.info(`Request took ${Date.now() - startTime} ms`)\r\n            resolve(result)\r\n          }\r\n        } catch (error) {\r\n          reject(error)\r\n        }\r\n      })\r\n    } else {\r\n      // Use permanent storage\r\n      if (getAllCharacterForms) {\r\n        // Return records for all known character forms\r\n        const requests = [\r\n          this._getWordsFromPermanentStorage(words, CedictData.characterForms.SIMPLIFIED),\r\n          this._getWordsFromPermanentStorage(words, CedictData.characterForms.TRADITIONAL)\r\n        ]\r\n        return Promise.all(requests).then((results) => ({\r\n          [CedictData.characterForms.SIMPLIFIED]: results[0],\r\n          [CedictData.characterForms.TRADITIONAL]: results[1]\r\n        }))\r\n      } else {\r\n        // Return records for a specified character set\r\n        return this._getWordsFromPermanentStorage(words, characterForm).then((result) => ({ [characterForm]: result }))\r\n      }\r\n    }\r\n  }\r\n\r\n  _getWordsFromVolatileStorage (words, characterForm) {\r\n    // If a single word value is provided, convert it into an array\r\n    if (!Array.isArray(words)) { words = [words] }\r\n    // Create an object with props for the words\r\n    let result = words.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n    // Retrieve from memory\r\n    if (this._schema.storage.stores.dictionary.volatileStorage.indexed) {\r\n      // Use in memory indexes to find values\r\n      words.forEach(word => {\r\n        const idx = (characterForm === CedictData.characterForms.SIMPLIFIED)\r\n          ? this.cedict.simplifiedHeadwordsIdx.get(word)\r\n          : this.cedict.traditionalHeadwordsIdx.get(word)\r\n        result[word] = idx ? idx.map(idx => this.cedict.entries.get(idx)) : []\r\n      })\r\n    } else {\r\n      // Indexes are not available, iterate over an array of values\r\n      this.cedict.entries.forEach(entry => {\r\n        const hw = (characterForm === CedictData.characterForms.SIMPLIFIED) ? entry.simplifiedHeadword : entry.traditionalHeadword\r\n        words.forEach(word => {\r\n          if (hw === word) {\r\n            result[word].push(entry)\r\n          }\r\n        })\r\n      })\r\n    }\r\n    return result\r\n  }\r\n\r\n  _getWordsFromPermanentStorage (words, characterForm) {\r\n    const index = (characterForm === CedictData.characterForms.SIMPLIFIED) ? 'simplifiedHwIdx' : 'traditionalHwIdx'\r\n    return this._storage.stores.dictionary.getEntries(words, { index })\r\n  }\r\n\r\n  /**\r\n   * Loads fresh CEDICT data from a remote server.\r\n   *\r\n   * @returns {Promise<undefined> | Promise<Error>} - Returns a promise that will be resolved with undefined\r\n   *          if data was loaded successfully or that will be rejected with an error with data loading will fail.\r\n   */\r\n  downloadData () {\r\n    const requests = this._schema.data.chunks.map(chunk => this.loadJson(`${this._schema.data.URI}/${chunk}`))\r\n    return Promise.all(requests).then(chunks => {\r\n      console.info('All chunks are loaded')\r\n      this.cedict.meta = chunks[0].metadata\r\n      delete this.cedict.meta.chunkNumber\r\n      this.populateVolatileStorage(chunks.map(piece => piece.entries).flat())\r\n    })\r\n  }\r\n\r\n  populateVolatileStorage (entries) {\r\n    if (this._schema.storage.stores.dictionary.volatileStorage.indexed) {\r\n      // Dictionary entries will be placed into a map using a primary key.\r\n      this.cedict.entries = new Map()\r\n      this.cedict.entries = entries.reduce(\r\n        (map, entry) => map.set(entry[this._schema.storage.stores.dictionary.primaryIndex.keyPath], entry),\r\n        this.cedict.entries\r\n      )\r\n      // Additional maps will be created for each index.\r\n      this.indexVolatileStorage()\r\n    } else {\r\n      // No indexes will be created and dictionary entries will be placed into an array\r\n      this.cedict.entries = entries\r\n    }\r\n  }\r\n\r\n  indexVolatileStorage () {\r\n    // Build an in-memory indexes\r\n    this.cedict.traditionalHeadwordsIdx = new Map()\r\n    this.cedict.simplifiedHeadwordsIdx = new Map()\r\n    this.cedict.entries.forEach(entry => {\r\n      this.cedict.traditionalHeadwordsIdx.has(entry.traditionalHeadword)\r\n        ? this.cedict.traditionalHeadwordsIdx.get(entry.traditionalHeadword).push(entry.index)\r\n        : this.cedict.traditionalHeadwordsIdx.set(entry.traditionalHeadword, [entry.index])\r\n      this.cedict.simplifiedHeadwordsIdx.has(entry.simplifiedHeadword)\r\n        ? this.cedict.simplifiedHeadwordsIdx.get(entry.simplifiedHeadword).push(entry.index)\r\n        : this.cedict.simplifiedHeadwordsIdx.set(entry.simplifiedHeadword, [entry.index])\r\n    })\r\n  }\r\n\r\n  writeToStorage () {\r\n    /*\r\n    `update` is used instead of `insert` here because `meta` store has only one record\r\n    and it's index must be as defined in `this.cedict.metaKey`.\r\n    Only the use of `update` allow to specify an index for the record.\r\n     */\r\n    const metaUpdate = this._storage.stores.meta.update([this.cedict.metaKey, this.cedict.meta])\r\n    const entriesArr = this.cedict.entries instanceof Map ? Array.from(this.cedict.entries.values()) : this.cedict.entries\r\n    console.info(`Write to storage, number of records is ${entriesArr.length}`)\r\n    const dictionaryUpdate = this._storage.stores.dictionary.insert(entriesArr)\r\n    return Promise.all([metaUpdate, dictionaryUpdate])\r\n  }\r\n\r\n  /**\r\n   * Loads a single JSON file from a specified URL and decodes it.\r\n   *\r\n   * @param {string} url - A strings that specifies a URL of a JSON file\r\n   * @returns {Promise<object>|Promise<Error>} - A promise that is resolved with a JSON object or\r\n   *          rejected with the error.\r\n   */\r\n  loadJson (url) {\r\n    return fetch(url).then(response => response.json())\r\n  }\r\n}\r\n\r\nCedictData.characterForms = {\r\n  SIMPLIFIED: 'simplified',\r\n  TRADITIONAL: 'traditional'\r\n}\r\n","import Store from '@lexisCs/cedict-service/store.js'\r\n\r\nexport default class CedictStorage {\r\n  constructor (schema) {\r\n    CedictStorage.checkSchemaValidity(schema)\r\n    this._schema = schema\r\n    this._db = null\r\n    this.stores = {}\r\n    Object.values(this._schema.stores).forEach(schema => { this.stores[schema.name] = new Store(schema) })\r\n  }\r\n\r\n  /**\r\n   * Checks if the schema supplied has all the necessary information in it.\r\n   * If schema is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} schema - A JSON like schema object.\r\n   */\r\n  static checkSchemaValidity (schema) {\r\n    if (!schema.name) throw new Error('Storage name is missing from a schema')\r\n    if (!schema.version) throw new Error('Storage version is missing from a schema')\r\n    if (!schema.stores) throw new Error('No stores are defined from a schema')\r\n  }\r\n\r\n  connect () {\r\n    console.info('connect has been called')\r\n    return new Promise((resolve, reject) => {\r\n      // If database does not exist, openRequest will create it and will trigger an onupgradeneeded followed by onsuccess\r\n      const openRequest = indexedDB.open(this._schema.name, this._schema.version) // eslint-disable-line prefer-const\r\n      openRequest.onupgradeneeded = this.create.bind(this, openRequest)\r\n\r\n      openRequest.onsuccess = () => {\r\n        console.info('DB open on success')\r\n        this._db = openRequest.result\r\n        Object.values(this.stores).forEach((store) => store.associateWith(this._db))\r\n        resolve()\r\n      }\r\n\r\n      openRequest.onerror = (error) => reject(error)\r\n    })\r\n  }\r\n\r\n  disconnect () {\r\n    if (this._db) {\r\n      this._db.close()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when database does not exist or is of incorrect version.\r\n   * This method cannot be called directly, only as a result of an onupgradeneeded event\r\n   * triggered by the open DB request.\r\n   *\r\n   * @param {IDBOpenDBRequest} openRequest - An open request that caused an onupgradeneeded event.\r\n   * @param {Function} reject - A reject function for promise declared in `connect()`.\r\n   */\r\n  create (openRequest, reject) {\r\n    console.info('DB open on upgrade needed (create)', openRequest)\r\n    this._db = openRequest.result\r\n    const storeCreateRequests = Object.values(this.stores).map(store => { store.associateWith(this._db).create() })\r\n    return Promise.all(storeCreateRequests)\r\n  }\r\n\r\n  destroy () {\r\n    return new Promise((resolve, reject) => {\r\n      this.disconnect()\r\n      const deleteRequest = indexedDB.deleteDatabase(this._schema.name)\r\n      deleteRequest.onsuccess = () => { console.info('database has been destroyed'); resolve() }\r\n      deleteRequest.onerror = () => { reject(new Error('Storage cannot be destroyed')) }\r\n    })\r\n  }\r\n}\r\n","import MessagingService from '@lexisCs/messaging/messaging-service.js'\r\nimport ResponseMessage from '@lexisCs/messaging/messages/response-message.js'\r\nimport Destination from '@lexisCs/messaging/destinations/window-iframe-destination.js'\r\nimport CedictData from '@lexisCs/cedict-service/cedict-data.js'\r\nimport CedictSchema from '@lexisCs/schemas/cedict.js'\r\n\r\n/**\r\n * This is a configuration of a WindowsIframeDestination that can be used to connect to CEDICT client service.\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nconst CedictDestinationConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'http://data-dev.alpheios.net',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n\r\nlet cedictData\r\n\r\nconst messageHandler = (request, responseFn) => {\r\n  if (!cedictData.isReady) {\r\n    responseFn(ResponseMessage.Error(request, new Error('Uninitialized')))\r\n    return\r\n  }\r\n\r\n  if (request.body.getWords) {\r\n    // This is a get words request\r\n    const startTime = Date.now()\r\n    cedictData.getWords(request.body.getWords.words)\r\n      .then((result) => {\r\n        console.info(`Request processing completed in ${Date.now() - startTime} ms`)\r\n        responseFn(ResponseMessage.Success(request, result))\r\n      }).catch((error) => responseFn(ResponseMessage.Error(request, error)))\r\n  } else {\r\n    responseFn(ResponseMessage.Error(request, new Error('Unsupported request')))\r\n  }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  const service = new MessagingService(new Destination(CedictDestinationConfig))\r\n  service.registerReceiverCallback(CedictDestinationConfig.name, messageHandler)\r\n\r\n  try {\r\n    cedictData = new CedictData(CedictSchema)\r\n  } catch (error) {\r\n    console.error(error)\r\n    return\r\n  }\r\n  cedictData.init().then(() => {\r\n    // TODO: A message to ease manual testing. Shall be removed in production\r\n    console.log('CEDICT service is ready')\r\n  }).catch((error) => console.error(error))\r\n})\r\n\r\nexport default CedictDestinationConfig\r\n","export default class Store {\r\n  constructor (schema) {\r\n    Store.checkSchemaValidity(schema)\r\n    this._schema = schema\r\n    // DB object is not available when store object is created. It must be added later.\r\n    this._db = null\r\n  }\r\n\r\n  /**\r\n   * Checks if the schema supplied has all the necessary information in it.\r\n   * If schema is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} schema - A JSON like schema object.\r\n   */\r\n  static checkSchemaValidity (schema) {\r\n    if (!schema.name) throw new Error('A store name is missing from a schema')\r\n    if (!schema.primaryIndex) throw new Error('A primaryIndex tree is missing from a schema')\r\n  }\r\n\r\n  associateWith (db) {\r\n    this._db = db\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * This method can be run only from `onupgradeneeded` callback\r\n   */\r\n  create () {\r\n    return new Promise((resolve, reject) => {\r\n      const options = this._schema.primaryIndex.keyPath ? { keyPath: this._schema.primaryIndex.keyPath } : undefined\r\n      console.info(`${this._schema.name} store create`, options)\r\n      const store = this._db.createObjectStore(this._schema.name, options)\r\n      if (this._schema.indexes) {\r\n        Object.values(this._schema.indexes).forEach(idx => {\r\n          console.info('Creating an index for', idx)\r\n          try {\r\n            store.createIndex(idx.name, idx.keyPath, { unique: idx.unique })\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  clear () {\r\n    let transaction = this._db.transaction(this._schema.name, Store.accessModes.READ_WRITE) // eslint-disable-line prefer-const\r\n\r\n    // create an object store on the transaction\r\n    let objectStore = transaction.objectStore(this._schema.name) // eslint-disable-line prefer-const\r\n\r\n    // Make a request to clear all the data out of the object store\r\n    let objectStoreRequest = objectStore.clear() // eslint-disable-line prefer-const\r\n\r\n    objectStoreRequest.onsuccess = (event) => {\r\n      // report the success of our request\r\n      console(`${this._schema.name}: clear request success`, event)\r\n    }\r\n\r\n    // report on the success of the transaction completing, when everything is done\r\n    transaction.oncomplete = (event) => {\r\n      console(`${this._schema.name}: clear transaction has been completed`, event)\r\n    }\r\n\r\n    transaction.onerror = (event) => {\r\n      console(`${this._schema.name}: clear transaction error`, event)\r\n    }\r\n  }\r\n\r\n  destroy () {\r\n    try {\r\n      this._db.deleteObjectStore(this._schema.name)\r\n    } catch (error) {\r\n      console.error(error)\r\n    }\r\n  }\r\n\r\n  // All records for a specific key\r\n  get (key, options) {\r\n    return this.getEntries([key], options).then((result) => result[key])\r\n  }\r\n\r\n  // Return all records for specific keys\r\n  getEntries (keys, { index = '' } = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this._db) reject(new Error('Database object is missing'))\r\n      if (!keys) keys = reject(new Error('No keys provided'))\r\n      if (!Array.isArray(keys)) keys = [keys]\r\n      const transaction = this._db.transaction(this._schema.name, Store.accessModes.READ)\r\n      const store = transaction.objectStore(this._schema.name)\r\n      // Create an object with keys as its props\r\n      let result = keys.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n      console.info('getEntries result is:', result)\r\n      /*\r\n      The order of request execution is guaranteed in IndexedDB.\r\n      This means that when the last request is completed all previous requests are done too.\r\n       */\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i]\r\n        let getRequest\r\n        if (index) {\r\n          // Use index to retrieve a record\r\n          console.info(`Retrieving using a ${index} index`)\r\n          const dbIndex = store.index(index)\r\n          getRequest = dbIndex.getAll(IDBKeyRange.only(key))\r\n        } else {\r\n          console.info('Retrieving without index')\r\n          getRequest = store.getAll(IDBKeyRange.only(key))\r\n        }\r\n        getRequest.onsuccess = () => {\r\n          const records = getRequest.result\r\n          console.info(`(${i}) Records returned for ${key} key are:`, records)\r\n          result[key] = getRequest.result\r\n          if (i === keys.length - 1) {\r\n            // A last request has been completed\r\n            resolve(result)\r\n          }\r\n        }\r\n      }\r\n      // Transaction is completed later than `getRequest.onsuccess` is triggered\r\n      transaction.oncomplete = () => console.info('getAll transaction is complete')\r\n      transaction.onerror = (error) => { console.info('getAll transaction error'); reject(error) }\r\n    })\r\n  }\r\n\r\n  getAllEntries () {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this._db) reject(new Error('Database object is missing'))\r\n      const transaction = this._db.transaction(this._schema.name, Store.accessModes.READ)\r\n      const store = transaction.objectStore(this._schema.name)\r\n      const getRequest = store.getAll()\r\n      getRequest.onsuccess = () => {\r\n        const records = getRequest.result\r\n        console.info('Records returned are:', records)\r\n        resolve(records)\r\n      }\r\n      // Transaction is completer later than `getRequest.onsuccess` is triggered\r\n      transaction.oncomplete = () => console.info('getAll transaction is complete')\r\n      transaction.onerror = (error) => { console.info('getAll transaction error'); reject(error) }\r\n    })\r\n  }\r\n\r\n  insert (records) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!records) { resolve() } // Do nothing\r\n      if (!Array.isArray(records)) { records = [records] }\r\n      if (!this._db) reject(new Error('Database object is missing'))\r\n      const transaction = this._db.transaction(this._schema.name, Store.accessModes.READ_WRITE)\r\n      const store = transaction.objectStore(this._schema.name)\r\n      records.forEach(record => store.put(record))\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (error) => reject(error)\r\n    })\r\n  }\r\n\r\n  update (keyValRecordsArr) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!keyValRecordsArr) resolve() // Do nothing\r\n      if (!Array.isArray(keyValRecordsArr)) reject(new Error('Record format must be [key,val] or [[key,val]]'))\r\n      if (!Array.isArray(keyValRecordsArr[0])) { keyValRecordsArr = [keyValRecordsArr] }\r\n      if (!this._db) reject(new Error('Database object is missing'))\r\n      const transaction = this._db.transaction(this._schema.name, Store.accessModes.READ_WRITE)\r\n      const store = transaction.objectStore(this._schema.name)\r\n      keyValRecordsArr.forEach(record => store.put(record[1], record[0]))\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (error) => reject(error)\r\n    })\r\n  }\r\n\r\n  count () {\r\n    return new Promise((resolve) => {\r\n      if (!this._db) throw new Error('Database object is missing')\r\n      const transaction = this._db.transaction(this._schema.name, Store.accessModes.READ)\r\n      const store = transaction.objectStore(this._schema.name)\r\n      const countRequest = store.count()\r\n      countRequest.onsuccess = () => { resolve(countRequest.result) }\r\n    })\r\n  }\r\n}\r\n\r\nStore.accessModes = {\r\n  READ: 'readonly',\r\n  READ_WRITE: 'readwrite'\r\n}\r\n","/**\r\n * @module Destination\r\n */\r\n\r\n/** Destination represents a place where messages are sent to and are received from (e.g. a windows) */\r\nexport default class Destination {\r\n  /**\r\n   * Creates an instance of a Destination object. Descendants may take configuration parameters through\r\n   * a second argument that they can define.\r\n   *\r\n   * @param {string} name - A name of a particular destination.\r\n   */\r\n  constructor ({ name }) {\r\n    if (!name) {\r\n      throw new Error('Destination name is missing')\r\n    }\r\n\r\n    /**\r\n     * A name of a destination. Used to refer to it within a messaging service.\r\n     *\r\n     * @type {string}\r\n     * @public\r\n     */\r\n    this.name = name\r\n\r\n    /**\r\n     * A function that will be called when a response from destination is received.\r\n     *\r\n     * @type {Function}\r\n     * @private\r\n     */\r\n    this._responseCallback = null\r\n  }\r\n\r\n  /**\r\n   * Registers a function to call when a response from destination is received.\r\n   *\r\n   * @param {Function} callbackFn - A function to be called when response is received.\r\n   */\r\n  registerResponseCallback (callbackFn) {\r\n    this._responseCallback = callbackFn\r\n  }\r\n}\r\n","/**\r\n * @module WindowIframeDestination\r\n */\r\nimport Destination from '@lexisCs/messaging/destinations/destination.js'\r\n\r\n/** WindowIframeDestination represents a content window within an iframe */\r\nexport default class WindowIframeDestination extends Destination {\r\n  /**\r\n   * @param {string} name - A name of a destination (for addressing a destination in a messaging service).\r\n   * @param {string} targetURL - A URL of a document within an iframe where messages will be sent.\r\n   * @param {string} targetIframeID - An ID of an iframe element (without `#`).\r\n   */\r\n  constructor ({ name, targetURL, targetIframeID } = {}) {\r\n    super({ name })\r\n\r\n    if (!targetURL) {\r\n      throw new Error('Target URL is not provided')\r\n    }\r\n\r\n    if (!targetIframeID) {\r\n      throw new Error('Target iframe ID is not provided')\r\n    }\r\n\r\n    /**\r\n     * A URL of a document within an iframe where messages will be sent.\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetURL = targetURL\r\n\r\n    /**\r\n     * An ID of an iframe element (without `#`).\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetIframeID = targetIframeID\r\n\r\n    window.addEventListener('message', this._responseHandler.bind(this), false)\r\n  }\r\n\r\n  /**\r\n   * Registers a function to be called an a receiving side when a message from origin to destination will arrive.\r\n   * This callback will receive the following arguments: the request object (of `RequestMessage` type)\r\n   * and the function that can be used to send a response.\r\n   *\r\n   * @param {Function} callbackFn - A function that will be called when a request will arrive to its destination.\r\n   */\r\n  registerReceiverCallback (callbackFn) {\r\n    window.addEventListener('message', this._requestHandler.bind(this, callbackFn), false)\r\n  }\r\n\r\n  /**\r\n   * A function that will be called to send a request from origin to destination.\r\n   *\r\n   * @param {RequestMessage} requestMessage - A request message object.\r\n   */\r\n  sendRequest (requestMessage) {\r\n    const iframe = document.querySelector(`#${this._targetIframeID}`)\r\n    if (!iframe) {\r\n      throw new Error(`An #${this._targetIframeID} iframe does not exist in the document`)\r\n    }\r\n    const iframeWindow = iframe.contentWindow\r\n    iframeWindow.postMessage(requestMessage, this._targetURL)\r\n  }\r\n\r\n  /**\r\n   * A function that is used to send a response from destination to origin.\r\n   *\r\n   * @param {ResponseMessage} responseMessage - A response message object.\r\n   */\r\n  sendResponse (responseMessage) {\r\n    window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when request arrives to its destination.\r\n   *\r\n   * @param {Function} callbackFn - A client's callback function that will be called and\r\n   *                                passed a request (a `RequestMessage` object).\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _requestHandler (callbackFn, event) {\r\n    // `data` prop of an event contains a request message object\r\n    let request = event.data // eslint-disable-line prefer-const\r\n    request.header.origin = event.origin\r\n    callbackFn(request, this.sendResponse.bind(this))\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when response arrives from destination to origin.\r\n   *\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _responseHandler (event) {\r\n    if (event.origin !== this._targetURL) {\r\n      // Message came from a destination we're not listening for\r\n      return\r\n    }\r\n\r\n    // `data` prop of an event contains a response message object\r\n    const responseMessage = event.data\r\n    if (this._responseCallback) {\r\n      this._responseCallback(responseMessage)\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @module Message\r\n */\r\nimport uuidv4 from 'uuid/v4'\r\n\r\n/** A base class for all types of messages */\r\nexport default class Message {\r\n  /**\r\n   * @param {object} body - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body) {\r\n    /**\r\n     * A message's role (@see {@link Message.roles}). Will be defined in descendants.\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.role = undefined\r\n\r\n    /**\r\n     * A type of the message. Used to distinguish one kind of message from the other (@see {@link Message.types}).\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.type = Message.types.GENERIC\r\n\r\n    /**\r\n     * A unique identifier of the message.\r\n     *\r\n     * @type {string}\r\n     */\r\n    this.ID = uuidv4()\r\n\r\n    /**\r\n     * An object with no methods representing a message body.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.body = body\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a message is request or response.\r\n */\r\nMessage.roles = {\r\n  REQUEST: 'Request',\r\n  RESPONSE: 'Response'\r\n}\r\n\r\n/**\r\n * Specifies a message type: what kind of message it is and what purpose it serves.\r\n */\r\nMessage.types = {\r\n  GENERIC: 'Generic'\r\n}\r\n","/**\r\n * @module ResponseMessage\r\n */\r\nimport Message from './message.js'\r\n\r\n/** A response message that is sent as an answer to the request message. */\r\nexport default class ResponseMessage extends Message {\r\n  /**\r\n   * @param {RequestMessage} request - A request that initiated this response. Used to copy routing information mostly.\r\n   * @param {object} body - A body of the response, a plain JS object with no methods.\r\n   * @param {string} responseCode - A code to indicate results of the request handling: Success, Failure, etc.\r\n   */\r\n  constructor (request, body = {}, responseCode = ResponseMessage.responseCodes.UNDEFINED) {\r\n    super(body)\r\n    this.role = Message.roles.RESPONSE\r\n    this.requestHeader = request.header || {}\r\n    this.requestHeader.ID = request.ID // ID of the request to match request and response\r\n    this.responseCode = responseCode\r\n  }\r\n\r\n  /**\r\n   * A builder for a response message with a SUCCESS response code.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {object} body - A body of response message.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @constructor\r\n   */\r\n  static Success (request, body) {\r\n    return new this(request, body, ResponseMessage.responseCodes.SUCCESS)\r\n  }\r\n\r\n  /**\r\n   * A builder for a message with an ERROR response code. Error information will be sent within the message body.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {Error} error - An error object containing error information.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @constructor\r\n   */\r\n  static Error (request, error) {\r\n    return new this(request, error, ResponseMessage.responseCodes.ERROR)\r\n  }\r\n\r\n  /**\r\n   * Checks if this message is a response (i.e. if it follows a response message format and conventions).\r\n   *\r\n   * @param {RequestMessage | ResponseMessage} message - A request or response message to be tested.\r\n   * @returns {boolean} - True if the message is a response, false otherwise.\r\n   */\r\n  static isResponse (message) {\r\n    return message.role &&\r\n      message.role === Message.roles.RESPONSE &&\r\n      message.requestHeader &&\r\n      message.requestHeader.ID\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a request was processed successfully or not.\r\n */\r\nResponseMessage.responseCodes = {\r\n  // Request was processed successfully.\r\n  // In this case a message body may contain a response data object or be empty.\r\n  SUCCESS: 'Success',\r\n\r\n  // There is no information about what was the outcome of request.\r\n  UNDEFINED: 'Undefined',\r\n\r\n  // Request failed. A message body will have information about an error.\r\n  ERROR: 'Error'\r\n}\r\n","/**\r\n * @module MessagingService\r\n */\r\nimport ResponseMessage from './messages/response-message'\r\nimport StoredRequest from './stored-request'\r\n\r\n/** A messaging for sending and receiving messages to and from various destinations */\r\nexport default class MessagingService {\r\n  constructor (destinations = []) {\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is the message ID and the value is an object\r\n     * that stores details about the message being sent.\r\n     *\r\n     * @type {Map<string, StoredRequest>}\r\n     */\r\n    this._messages = new Map()\r\n\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is a destination name and the value is\r\n     * the Destination object.\r\n     *\r\n     * @type {Map<string, Destination>}\r\n     */\r\n    this._destinations = new Map()\r\n\r\n    // If provided as a singular value convert destination into an array\r\n    if (!Array.isArray(destinations)) { destinations = [destinations] }\r\n    destinations.forEach(destination => this.registerDestination(destination))\r\n  }\r\n\r\n  /**\r\n   * Registers a new destination by adding it to the destinations map and setting a response callback.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  registerDestination (destination) {\r\n    if (this._destinations.has(destination.name)) {\r\n      throw new Error('Destination already exists')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    destination.registerResponseCallback(this.dispatchMessage.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Updates a destinations that is already registered.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  updateDestination (destination) {\r\n    if (!this._destinations.has(destination.name)) {\r\n      throw new Error('Cannot update a destination that does not exist')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    destination.registerResponseCallback(this.dispatchMessage.bind(this))\r\n  }\r\n\r\n  /**\r\n   * A function to handle incoming messages.\r\n   *\r\n   * @param {ResponseMessage} message - An incoming response message.\r\n   */\r\n  dispatchMessage (message) {\r\n    if (!ResponseMessage.isResponse(message)) {\r\n      console.error('A message not following a response format will be ignored:', message)\r\n      return\r\n    }\r\n\r\n    if (!this._messages.has(message.requestHeader.ID)) {\r\n      console.error(`Ignoring a message with request ID ${message.requestHeader.ID} not registered in a request list`, message)\r\n      return\r\n    }\r\n    const requestInfo = this._messages.get(message.requestHeader.ID)\r\n    window.clearTimeout(requestInfo.timeoutID) // Clear a timeout\r\n    const responseCode = message.responseCode\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // There was an error returned. An error info is in the message body.\r\n      requestInfo.reject(message.body)\r\n    } else {\r\n      // Request was processed without errors\r\n      requestInfo.resolve(message)\r\n    }\r\n    this._messages.delete(message.requestHeader.ID) // Remove request info from the map\r\n  }\r\n\r\n  /**\r\n   * Registers an outgoing request within a request map. Returns a promise that will be fulfilled when\r\n   * a response will be received or rejected when a timeout will expire.\r\n   *\r\n   * @param {RequestMessage} request - An outgoing request.\r\n   * @param {number} timeout - A number of milliseconds we'll wait for response before rejecting a promise.\r\n   * @returns {Promise} - A promise that will be resolved with the message response or rejected with an error info.\r\n   */\r\n  registerRequest (request, timeout = 10000) {\r\n    if (this._messages.has(request.ID)) throw new Error(`Request with ${request.ID} ID is already registered`)\r\n    let storedRequest = new StoredRequest(request) // eslint-disable-line prefer-const\r\n    this._messages.set(request.ID, storedRequest)\r\n    storedRequest.timeoutID = window.setTimeout((requestID) => {\r\n      storedRequest.reject(new Error(`Timeout has been expired for a message with request ID ${request.ID}`))\r\n      this._messages.delete(requestID) // Remove request record from the map\r\n    }, timeout)\r\n    return storedRequest.promise\r\n  }\r\n\r\n  /**\r\n   * Sends a request message to a specific destination.\r\n   *\r\n   * @param {string} destName - A name of a destination where request will be sent to.\r\n   * @param {RequestMessage} request - A request message to be sent.\r\n   * @param {number} timeout - How many milliseconds to wait for a response.\r\n   * @returns {Promise<ResponseMessage> | Promise<Error> | Promise<object>} - A promise either resolved\r\n   *          with response message or rejected with the error info.\r\n   */\r\n  sendRequestTo (destName, request, timeout = 10000) {\r\n    if (!destName) {\r\n      throw new Error('Destination name is not provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    const promise = this.registerRequest(request, timeout)\r\n    this._destinations.get(destName).sendRequest(request)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Sets a function to be called on a destination side every time a message from the origin arrives.\r\n   *\r\n   * @param {string} destName - A name of a destination to listen to messages from.\r\n   * @param {Function} callbackFn - A function to call when message is arrived. A message will be passed\r\n   *                                to this function as an argument.\r\n   */\r\n  registerReceiverCallback (destName, callbackFn) {\r\n    if (!destName) {\r\n      throw new Error('No destination name provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    this._destinations.get(destName).registerReceiverCallback(callbackFn)\r\n  }\r\n}\r\n","/**\r\n * @module StoredRequest\r\n */\r\n\r\n/** Stores information about request being sent via the messaging service */\r\nexport default class StoredRequest {\r\n  constructor () {\r\n    /**\r\n     * A function to resolve the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.resolve = null\r\n\r\n    /**\r\n     * A function to reject the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.reject = null\r\n\r\n    // A promise that will be resolved or rejected when the response will arrive or the timeout will expire\r\n    this.promise = new Promise(this.executor.bind(this))\r\n  }\r\n\r\n  executor (resolve, reject) {\r\n    this.resolve = resolve\r\n    this.reject = reject\r\n  }\r\n}\r\n","const cedict = {\r\n  storage: {\r\n    name: 'cedict',\r\n    version: 1,\r\n    stores: {\r\n      meta: {\r\n        name: 'meta',\r\n        primaryIndex: {\r\n          auto: true\r\n        }\r\n      },\r\n      dictionary: {\r\n        name: 'dictionary',\r\n        primaryIndex: {\r\n          keyPath: 'index'\r\n        },\r\n        indexes: {\r\n          traditional: {\r\n            name: 'traditionalHwIdx',\r\n            keyPath: 'traditionalHeadword',\r\n            unique: false\r\n          },\r\n          simplified: {\r\n            name: 'simplifiedHwIdx',\r\n            keyPath: 'simplifiedHeadword',\r\n            unique: false\r\n          }\r\n        },\r\n        volatileStorage: {\r\n          enabled: false,\r\n          indexed: true\r\n        },\r\n        permanentStorage: {\r\n          enabled: true,\r\n          // Searching within permanent storage with no indexes is currently not implemented\r\n          indexed: true\r\n        }\r\n      }\r\n    }\r\n  },\r\n  data: {\r\n    version: 20191029,\r\n    revision: 1,\r\n    recordsCount: 117735,\r\n    URI: 'http://data-dev.alpheios.net/cedict',\r\n    chunks: [\r\n      'cedict-v20191029-c001.json',\r\n      'cedict-v20191029-c002.json',\r\n      'cedict-v20191029-c003.json',\r\n      'cedict-v20191029-c004.json'\r\n    ]\r\n  }\r\n}\r\n\r\nexport default cedict\r\n"],"sourceRoot":""}