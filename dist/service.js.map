{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/v4.js","webpack:///./src/cedict-service/cedict-permanent-storage.js","webpack:///./src/cedict-service/cedict.js","webpack:///./src/cedict-service/indexed-db-store.js","webpack:///./src/cedict-service/service.js","webpack:///./src/cedict-service/storage.js","webpack:///./src/cedict-service/store.js","webpack:///./src/configurations/cedict.js","webpack:///./src/messaging/destinations/destination.js","webpack:///./src/messaging/destinations/window-iframe-destination.js","webpack:///./src/messaging/messages/message.js","webpack:///./src/messaging/messages/request-message.js","webpack:///./src/messaging/messages/response-message.js","webpack:///./src/messaging/messaging-service.js","webpack:///./src/messaging/stored-request.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjCA,UAAU,mBAAO,CAAC,yDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACwD;AACgB;;AAExE;AACe,qCAAqC,0EAAO;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC,mFAAc,gBAAgB;AACrG;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS,WAAW,OAAO,kBAAkB,OAAO,wBAAwB,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC;AACvC,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5LA;AAAA;AAAA;AAAA;AACA;AACA;AACwF;;AAExF;AACe;AACf;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,wBAAwB,2FAAsB;;AAE9C;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,iBAAiB;AAC9B;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8FAA8F,6BAA6B,IAAI,cAAc;AAC7I;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAyC;AAChE,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2EAA2E,wCAAwC;AACnH;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,2EAA2E,2BAA2B;AACtG;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,yDAAyD,uBAAuB,qBAAqB,IAAI;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;;AAEA;AACA;AACA;AACA,eAAe,SAAS,mCAAmC,mBAAmB;AAC9E;AACA;AACA;AACA,oFAAoF,6BAA6B,GAAG,MAAM;AAC1H;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9aA;AAAA;AAAA;AAAA;AACA;AACA;AACoD;;AAEpD;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,WAAW,OAAO;AAClB,cAAc,OAAO;AACrB;;AAEA;AACe,6BAA6B,wEAAK;AACjD;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,kEAAkE,oDAAoD;AACtH;AACA;AACA;AACA;AACA,sDAAsD,qBAAqB;AAC3E,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO,YAAY;AAChC,aAAa,OAAO;AACpB;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO,YAAY;AAChC,aAAa,OAAO;AACpB;AACA;AACA,eAAe,SAAS,eAAe,iBAAiB;AACxD;AACA;AACA;AACA,qBAAqB,oBAAoB,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB,qBAAqB,IAAI;AACtG;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACO;AACS;AAChC;AACM;AAC5D,6BAA6B,yEAAM;;AAEnC;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uFAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,uFAAe;AAClC,OAAO,8BAA8B,uFAAe;AACpD,GAAG;AACH,eAAe,uFAAe;AAC9B;AACA;;AAEA;AACA,sBAAsB,+EAAgB,KAAK,oGAAW;AACtD;;AAEA;AACA,qBAAqB,yEAAM,CAAC,yEAAY;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAEuD;;;;;;;;;;;;;ACtFxD;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACe;AACf;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO,YAAY;AAChC,eAAe,SAAS,cAAc,iBAAiB;AACvD;AACA;AACA;AACA,qBAAqB,aAAa,KAAK;AACvC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/KA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM;;;;;;;;;;;;;ACzIrB;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB;AACA,gBAAgB,OAAO,KAAK;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AACA;AACA;AACwE;;AAExE;AACe,sCAAsC,sFAAW;AAChE;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,gBAAgB,kCAAkC,KAAK;AACvD,WAAW,OAAO;;AAElB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC4B;;AAE5B;AACe;AACf;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,+BAA+B,oBAAoB;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA,4FAA4F,oBAAoB;AAChH;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,8CAAM;;AAEpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACkC;;AAElC;AACe,6BAA6B,mDAAO;AACnD;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,gBAAgB,mDAAO;;AAEvB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC4D;AACe;;AAE3E;AACe,8BAA8B,8EAAO;AACpD;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,aAAa,OAAO;AACpB;AACA,iCAAiC;AACjC;AACA;AACA;AACA,gBAAgB,8EAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,eAAe,gBAAgB;AAC/B;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,MAAM;AACnB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,QAAQ;AACvB;AACA;AACA;AACA,uBAAuB,8EAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACyD;AACb;;AAE5C;AACe;AACf;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,SAAS,kEAAe;AACxB;AACA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,kEAAe;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA,wEAAwE,WAAW;AACnF,4BAA4B,uDAAa;AACzC;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjJA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"service.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/cedict-service/service.js\");\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","/**\r\n * @module CedictStorage\r\n */\r\nimport Storage from '@lexisCs/cedict-service/storage.js'\r\nimport IndexedDbStore from '@lexisCs/cedict-service/indexed-db-store.js'\r\n\r\n/** A representation of a permanent data storage for CEDICT dictionary */\r\nexport default class CedictPermanentStorage extends Storage {\r\n  constructor (configuration) {\r\n    super(configuration)\r\n    this._configuration = configuration\r\n    this._db = null\r\n    // A map to keep store objects\r\n\r\n    /**\r\n     * A map to keep store objects. CedictPermanentStorage has two: 'meta' and 'dictionary'.\r\n     * The key is the store name and the value is a store object.\r\n     *\r\n     * @type {Map<string, IndexedDbStore>}\r\n     */\r\n    this._stores = new Map()\r\n    // A key that provides access to the metadata object in the `meta` store.\r\n    this.metaKey = 1\r\n    Object.values(this._configuration.stores)\r\n      .forEach(storeConfig => { this._stores.set(storeConfig.name, new IndexedDbStore(storeConfig)) })\r\n  }\r\n\r\n  /**\r\n   * Called internally by a super class to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(CedictPermanentStorage.errMsgs.NO_STORAGE_NAME)\r\n    if (!configuration.version) throw new Error(CedictPermanentStorage.errMsgs.NO_STORAGE_VERSION)\r\n    if (!configuration.stores) throw new Error(CedictPermanentStorage.errMsgs.NO_STORES)\r\n  }\r\n\r\n  /**\r\n   * Asserts that a database connection is opened.\r\n   *\r\n   * @private\r\n   */\r\n  _assertConnection () {\r\n    if (!this._db) throw new Error(CedictPermanentStorage.errMsgs.CLOSED_CONNECTION)\r\n  }\r\n\r\n  /**\r\n   * Checks if a store with a given name exists.\r\n   *\r\n   * @param {string} storeName - The name of the store.\r\n   * @returns {boolean} true if store exists or false otherwise.\r\n   */\r\n  hasStore (storeName) {\r\n    return this._stores.has(storeName)\r\n  }\r\n\r\n  /**\r\n   * Returns a store object. It will throw an error if store does not exist\r\n   * of if a connection to the database is closed.\r\n   *\r\n   * @param {string} storeName - A name of a store to get.\r\n   * @returns {IndexedDbStore} An instance of a store object.\r\n   */\r\n  getStore (storeName) {\r\n    if (!this._stores.has(storeName)) throw new Error(CedictPermanentStorage.errMsgs.MISSING_STORE)\r\n    this._assertConnection()\r\n    return this._stores.get(storeName)\r\n  }\r\n\r\n  /**\r\n   * Returns information to verify storage integrity. Integrity data is specific for each particular\r\n   * storage type.\r\n   *\r\n   * @returns {Promise<{metadata: {object}, recordsInMeta: {number}, recordsInDictionary: {number}}>|Promise<Error>}\r\n   *          Returns a promise that is resolved an object with storage integrity data or is rejected\r\n   *          if storage integrity is broken. Integrity data object contains the following information:\r\n   *          a CEDICT metadata object that is contained in the `meta` store, number of records\r\n   *          in `meta` and `dictionary` _stores.\r\n   */\r\n  getIntegrityData () {\r\n    this._assertConnection()\r\n    let integrityRequests\r\n    try {\r\n      integrityRequests = [this._stores.get('meta'), this._stores.get('dictionary')].map(store => store.count()) // eslint-disable-line prefer-const\r\n      integrityRequests.push(this._stores.get('meta').get(this.metaKey))\r\n    } catch (error) {\r\n      return Promise.reject(error)\r\n    }\r\n    return Promise.all(integrityRequests).then(([recordsInMeta, recordsInDictionary, metadata]) => {\r\n      if (!metadata || metadata.length === 0) throw new Error(CedictPermanentStorage.errMsgs.NO_META)\r\n      return { recordsInMeta, recordsInDictionary, metadata: metadata[0] }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * This is a primary method of establishing connection to the storage.\r\n   * If storage and _stores it contains do not exist, connect() will create them.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          established successfully or is rejected if connection fails.\r\n   */\r\n  connect () {\r\n    return new Promise((resolve, reject) => {\r\n      // If database does not exist, openRequest will create it and will trigger an onupgradeneeded followed by onsuccess\r\n      const openRequest = indexedDB.open(this._configuration.name, this._configuration.version) // eslint-disable-line prefer-const\r\n      openRequest.onupgradeneeded = this._create.bind(this, openRequest)\r\n\r\n      openRequest.onsuccess = () => {\r\n        this._db = openRequest.result\r\n        this._stores.forEach(store => store.associateWith(this._db))\r\n        resolve()\r\n      }\r\n\r\n      openRequest.onerror = (error) => { reject(error) }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Disconnects from the storage.\r\n   *\r\n   * @returns {Promise<undefined>} Always returns a resolved promise.\r\n   */\r\n  disconnect () {\r\n    if (this._db) {\r\n      this._stores.forEach(store => store.dissociate())\r\n      this._db.close()\r\n      this._db = null\r\n    }\r\n    return Promise.resolve()\r\n  }\r\n\r\n  /**\r\n   * Clears all stores in a storage.\r\n   *\r\n   * @returns {Promise<any>|Promise<Error>} A promise that is resolved when all stores are cleared\r\n   *          or is rejected if clearing at least one of the stores failed.\r\n   */\r\n  clear () {\r\n    this._assertConnection()\r\n    return Promise.all(Array.from(this._stores.values()).map(store => store.clear()))\r\n  }\r\n\r\n  /**\r\n   * Called to create a storage when one does not exist or is of incorrect version.\r\n   * This method cannot be called directly, only as a result of an onupgradeneeded event\r\n   * triggered by the open DB request. Use 'connect()` to establish connection ot a database,\r\n   * and it will invoke `_create()` if necessary.\r\n   *\r\n   * @param {IDBOpenDBRequest} openRequest - An open request that caused an onupgradeneeded event.\r\n   * @param {Function} reject - A reject function for promise declared in `connect()`.\r\n   * @returns {Promise} A promise that is resolved if storage is created successfully or\r\n   *                    is rejected otherwise.\r\n   */\r\n  _create (openRequest, reject) {\r\n    this._db = openRequest.result\r\n    const storeCreateRequests = Array.from(this._stores.values()).map(store => store.associateWith(this._db).create())\r\n    return Promise.all(storeCreateRequests)\r\n  }\r\n\r\n  /**\r\n   * Destroys a storage and all the _stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all _stores were destroyed successfully or is rejected if operations fails.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertConnection()\r\n      this.disconnect().then(() => {\r\n        const deleteRequest = indexedDB.deleteDatabase(this._configuration.name)\r\n        deleteRequest.onsuccess = () => { resolve() }\r\n        deleteRequest.onerror = () => { reject(new Error(CedictPermanentStorage.errMsgs.DESTRUCTION_ERROR)) }\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nCedictPermanentStorage.errMsgs = {\r\n  NO_STORAGE_NAME: 'Storage name is missing from a configuration',\r\n  NO_STORAGE_VERSION: 'Storage version is missing from a configuration',\r\n  NO_STORES: 'No stores are defined in a configuration',\r\n  NO_META: 'Metadata store has no records',\r\n  DESTRUCTION_ERROR: 'Unable to destroy a storage',\r\n  MISSING_STORE: 'The store requested does not exist',\r\n  CLOSED_CONNECTION: 'Connection to the store is closed'\r\n}\r\n","/**\r\n * @module CedictData\r\n */\r\nimport CedictPermanentStorage from '@lexisCs/cedict-service/cedict-permanent-storage.js'\r\n\r\n/** A class to serve data from CEDICT */\r\nexport default class Cedict {\r\n  /**\r\n   * @param {object} configuration - An object that describes a configuration of a CEDICT data object.\r\n   */\r\n  constructor (configuration) {\r\n    Cedict.checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n\r\n    /**\r\n     * Whether the object is ready to serve data or not.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    this.isReady = false\r\n\r\n    this._storage = new CedictPermanentStorage(this._configuration.storage)\r\n\r\n    /**\r\n     * If CEDICT be stored in memory this object will hold all its data.\r\n     *\r\n     * @type {{entries: object[]|Map, meta: {}}}\r\n     */\r\n    this.cedict = {\r\n\r\n      // A dictionary's metadata\r\n      meta: {},\r\n\r\n      metaKey: 1,\r\n\r\n      /**\r\n       * If data is stored in memory `entries` will keep either\r\n       * an array of dictionary records (if no in memory indexes will be employed) or\r\n       * a map of dictionary records (if in memory indexes will be used).\r\n       * If dictionary data will be stored in permanents storage only `entries` will be null\r\n       */\r\n      dictionary: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `traditionalHeadwordsIdx`\r\n       * will hold a map: Map<traditionalHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      traditionalHeadwordsIdx: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `simplifiedHeadwordsIdx`\r\n       * will hold a map: Map<simplifiedHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      simplifiedHeadwordsIdx: null\r\n    }\r\n\r\n    /*\r\n    If characterForm is not specified in the request we will search for records with the\r\n    preferred character form specified below first. If any results for that character form will be found,\r\n    only those ones will be returned to the client. If no results for the preferred character form\r\n    are in the dictionary then we will search for records with other character forms.\r\n     */\r\n    this.preferredCharacterForm = Cedict.characterForms.TRADITIONAL\r\n\r\n    /*\r\n    This is a character form we will fallback into if matches for the preferred one are not found.\r\n     */\r\n    this.fallbackCharacterForm = Cedict.characterForms.SIMPLIFIED\r\n  }\r\n\r\n  /**\r\n   * Checks if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   */\r\n  static checkConfiguration (configuration) {\r\n    if (!configuration.storage) throw new Error(Cedict.errMsgs.CONF_NO_STORAGE)\r\n    if (!configuration.storage.stores) throw new Error(Cedict.errMsgs.CONF_NO_STORES)\r\n    if (!configuration.storage.stores.dictionary) throw new Error(Cedict.errMsgs.CONF_NO_DICT)\r\n    if (!configuration.storage.stores.dictionary.primaryIndex) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PRIMARY_IDX)\r\n    if (!configuration.storage.stores.dictionary.primaryIndex.hasOwnProperty('keyPath')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PRIMARY_IDX_KEY_PATH)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage.hasOwnProperty('enabled')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE_ENABLED)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage.hasOwnProperty('indexed')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE_INDEXED)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage.hasOwnProperty('enabled')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM_ENABLED)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage.hasOwnProperty('indexed')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM_INDEXED)\r\n    if (!configuration.data) throw new Error(Cedict.errMsgs.CONF_NO_DATA)\r\n    if (!configuration.data.version) throw new Error(Cedict.errMsgs.CONF_NO_DATA_VER)\r\n    if (!configuration.data.revision) throw new Error(Cedict.errMsgs.CONF_NO_DATA_REV)\r\n    if (!configuration.data.recordsCount) throw new Error(Cedict.errMsgs.CONF_NO_DATA_REC_COUNT)\r\n    if (!configuration.data.URI) throw new Error(Cedict.errMsgs.CONF_NO_DATA_URI)\r\n    if (!configuration.data.chunks || configuration.data.chunks.length === 0) throw new Error(Cedict.errMsgs.CONF_NO_DATA_CHUNKS)\r\n  }\r\n\r\n  /**\r\n   * Initializes a data object.\r\n   *\r\n   * @returns {Promise<undefined> | Promise<Error>} - A promise\r\n   */\r\n  init () {\r\n    return new Promise((resolve, reject) => {\r\n      // `storage.connect()` will create a database if it does not exist yet.\r\n      return this._storage.connect()\r\n        .catch((error) => {\r\n          console.error('Connection to storage cannot be established')\r\n          reject(error)\r\n        })\r\n        .then(() => this._storage.getIntegrityData())\r\n        .then((integrityData) => {\r\n          /*\r\n          Integrity data has been returned successfully which means database structure is OK.\r\n          Let's check if there is a new version of data available on a server.\r\n           */\r\n          if (!this.isStorageIntact(integrityData)) {\r\n            throw new Error('Storage is outdated')\r\n          }\r\n          // Data in storage is fresh so we can read it into memory structures if we have that option enabled\r\n          if (this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n            return this._storage.getStore('dictionary').getAllEntries()\r\n              .then((entries) => this._populateVolatileStorage(integrityData.metadata, entries))\r\n              .catch((error) => reject(error))\r\n          }\r\n        })\r\n        .catch(() => {\r\n          // Data in permanent storage needs to be updated\r\n          return this.removePermanentData()\r\n            // `connect()` will create storage and stores\r\n            .then(() => this._storage.connect())\r\n            .then(() => this._downloadData())\r\n            .then(({ meta, dictionary }) => {\r\n              if (this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n                this._populateVolatileStorage(meta, dictionary)\r\n              }\r\n              // Even if permanent storage is disabled we will still populate in order to avoid downloading data again\r\n              return this._populatePermanentStorage(meta, dictionary)\r\n                .then(() => Promise.resolve())\r\n                .catch((error) => {\r\n                  console.error('Unable to store CEDICT data to IndexedDB.', error)\r\n                  // Cannot write CEDICT data to IndexedDB. Will fall back to an in-memory location\r\n                  if (!this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n                    console.warn('Switched to in-memory placement of CEDICT data')\r\n                    this._configuration.storage.stores.dictionary.volatileStorage.enabled = true\r\n                    this._populateVolatileStorage(meta, dictionary)\r\n                  }\r\n                  return Promise.resolve()\r\n                })\r\n            })\r\n        })\r\n        .catch((error) => reject(error))\r\n        .then(() => {\r\n          this.isReady = true\r\n          resolve()\r\n        })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes all permanent data associated with CEDICT data object.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if data is cleared successfully\r\n   *          or rejected if operation failed.\r\n   */\r\n  removePermanentData () {\r\n    return this._storage.destroy()\r\n  }\r\n\r\n  /**\r\n   * Checks if the character form supplied is the one we have records upon.\r\n   *\r\n   * @param {Cedict.characterForms} characterForm - A string identifying a character form.\r\n   * @returns {boolean} True if there is information on this form, false otherwise.\r\n   */\r\n  static isSupportedCharacterForm (characterForm) {\r\n    return Array.from(Object.values(Cedict.characterForms)).includes(characterForm)\r\n  }\r\n\r\n  /**\r\n   * Verifies whether data in a storage is OK by checking its integrity information.\r\n   *\r\n   * @param {object} integrityData - A JSON-like object containing a storage integrity data.\r\n   * @returns {boolean} True if storage is intact and false otherwise.\r\n   */\r\n  isStorageIntact (integrityData) {\r\n    return (\r\n      integrityData.recordsInMeta === 1 &&\r\n      integrityData.recordsInDictionary === this._configuration.data.recordsCount &&\r\n      integrityData.metadata.version === this._configuration.data.version &&\r\n      integrityData.metadata.revision === this._configuration.data.revision\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records from CEDICT dictionary for one or several Chinese words.\r\n   *\r\n   * @param {string|[string]} words - A single Chinese word or an array of Chinese words.\r\n   * @param {string|undefined} [characterForm=undefined] - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {object} - Returns an object whose keys are character forms and values are\r\n   *          objects with requested words as keys and values are arrays of CEDICT records\r\n   *          that has those words.\r\n   */\r\n  getWords (words, characterForm) {\r\n    // CedictData object is not prepared to serve this request\r\n    if (!this.isReady) return Promise.reject(new Error(Cedict.errMsgs.NOT_READY))\r\n\r\n    let characterFormIsNotKnown = true\r\n    // If character form is not specified it will try to find a best suitable one\r\n    if (typeof characterForm !== 'undefined') {\r\n      // Some value is provided for a characterForm\r\n      if (!Cedict.isSupportedCharacterForm(characterForm)) return Promise.reject(new Error(`${Cedict.errMsgs.BAD_CHAR_FORM} \"${characterForm}\"`))\r\n      characterFormIsNotKnown = false\r\n    }\r\n\r\n    // Nothing to do\r\n    if (!words) return Promise.resolve({})\r\n\r\n    // Decide whether word entries will be retrieved from memory or form a permanent storage\r\n    const getWordsFunc = this._configuration.storage.stores.dictionary.volatileStorage.enabled\r\n      ? this._getWordsFromVolatileStorage.bind(this)\r\n      : this._getWordsFromPermanentStorage.bind(this)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (characterFormIsNotKnown) {\r\n        // Search using preferred character form first\r\n        getWordsFunc(words, this.preferredCharacterForm)\r\n          .then((entries) => {\r\n            if (Cedict._getResultRecordsCount(entries) > 0) {\r\n              // There are matches with the preferred character form, we need to search no longer\r\n              resolve({ [this.preferredCharacterForm]: entries })\r\n            } else {\r\n              // Search using fallback character form\r\n              return getWordsFunc(words, this.fallbackCharacterForm)\r\n            }\r\n          })\r\n          .then((entries) => {\r\n            // Results for the fallback character form\r\n            const result = (Cedict._getResultRecordsCount(entries) > 0) ? { [this.fallbackCharacterForm]: entries } : {}\r\n            resolve(result)\r\n          })\r\n          .catch((error) => reject(error))\r\n      } else {\r\n        // Return records for a specified character set\r\n        getWordsFunc(words, characterForm)\r\n          .then((entries) => {\r\n            const result = (Cedict._getResultRecordsCount(entries) > 0) ? { [characterForm]: entries } : {}\r\n            resolve(result)\r\n          })\r\n          .catch((error) => reject(error))\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records for given words from an in-memory storage.\r\n   * It returns a promise to make it signature compatible with other word retrieval functions.\r\n   *\r\n   * @param {[string]} words - An array of Chinese words.\r\n   * @param {string} characterForm - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {Promise<object> | Promise<Error>} - Returns a promise that is resolved with an object\r\n   *          whose keys are the words requested and values are arrays of CEDICT records that has those words.\r\n   *          If an error occurred, the promise is rejected with an error.\r\n   */\r\n  _getWordsFromVolatileStorage (words, characterForm) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        // If a single word value is provided, convert it into an array\r\n        if (!Array.isArray(words)) { words = [words] }\r\n        // Create an object with props for the words\r\n        let result = words.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n        // Retrieve from memory\r\n        if (this._configuration.storage.stores.dictionary.volatileStorage.indexed) {\r\n          // Use in memory indexes to find values\r\n          words.forEach(word => {\r\n            const idx = (characterForm === Cedict.characterForms.SIMPLIFIED)\r\n              ? this.cedict.simplifiedHeadwordsIdx.get(word)\r\n              : this.cedict.traditionalHeadwordsIdx.get(word)\r\n            result[word] = idx ? idx.map(idx => this.cedict.dictionary.get(idx)) : []\r\n          })\r\n        } else {\r\n          // Indexes are not available, iterate over an array of values\r\n          this.cedict.dictionary.forEach(entry => {\r\n            const hw = (characterForm === Cedict.characterForms.SIMPLIFIED) ? entry.simplifiedHeadword : entry.traditionalHeadword\r\n            words.forEach(word => {\r\n              if (hw === word) {\r\n                result[word].push(entry)\r\n              }\r\n            })\r\n          })\r\n        }\r\n        resolve(result)\r\n      } catch (error) {\r\n        reject(error)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records for given words from a permanent storage.\r\n   *\r\n   * @param {[string]} words - An array of Chinese words.\r\n   * @param {string} characterForm - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {Promise<object> | Promise<Error>} - Returns a promise that is resolved with an object\r\n   *          whose keys are the words requested and values are arrays of CEDICT records that has those words.\r\n   *          If an error occurred, the promise is rejected with an error.\r\n   */\r\n  _getWordsFromPermanentStorage (words, characterForm) {\r\n    const index = (characterForm === Cedict.characterForms.SIMPLIFIED) ? 'simplifiedHwIdx' : 'traditionalHwIdx'\r\n    return this._storage.getStore('dictionary').getEntries(words, { index })\r\n  }\r\n\r\n  /**\r\n   * Loads fresh CEDICT data from a remote server.\r\n   *\r\n   * @returns {Promise<{meta: object, dictionary: object[]}> | Promise<Error>} - Returns a promise that will be resolved with undefined\r\n   *          if data was loaded successfully or that will be rejected with an error with data loading will fail.\r\n   */\r\n  _downloadData () {\r\n    const requests = this._configuration.data.chunks.map(chunk => this._loadJson(`${this._configuration.data.URI}/${chunk}`))\r\n    return Promise.all(requests).then(chunks => {\r\n      let meta = chunks[0].metadata // eslint-disable-line prefer-const\r\n      delete this.cedict.meta.chunkNumber\r\n      return { meta, dictionary: chunks.map(piece => piece.entries).flat() }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Stores CEDICT dictionary data into an in-memory storage.\r\n   *\r\n   * @param {object} meta - A metadata object.\r\n   * @param {object[]} dictionary - An array of dictionary records.\r\n   */\r\n  _populateVolatileStorage (meta, dictionary) {\r\n    this.cedict.meta = meta\r\n    if (this._configuration.storage.stores.dictionary.volatileStorage.indexed) {\r\n      // Dictionary entries will be placed into a map using a primary key.\r\n      this.cedict.dictionary = new Map()\r\n      dictionary.forEach(entry => this.cedict.dictionary.set(entry[this._configuration.storage.stores.dictionary.primaryIndex.keyPath], entry))\r\n      // Additional maps will be created for each index.\r\n      this._indexVolatileStorage()\r\n    } else {\r\n      // No indexes will be created and dictionary entries will be placed into an array\r\n      this.cedict.dictionary = dictionary\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates indexes for an in-memory storage.\r\n   */\r\n  _indexVolatileStorage () {\r\n    this.cedict.traditionalHeadwordsIdx = new Map()\r\n    this.cedict.simplifiedHeadwordsIdx = new Map()\r\n    this.cedict.dictionary.forEach(entry => {\r\n      this.cedict.traditionalHeadwordsIdx.has(entry.traditional.headword)\r\n        ? this.cedict.traditionalHeadwordsIdx.get(entry.traditional.headword).push(entry.index)\r\n        : this.cedict.traditionalHeadwordsIdx.set(entry.traditional.headword, [entry.index])\r\n      this.cedict.simplifiedHeadwordsIdx.has(entry.simplified.headword)\r\n        ? this.cedict.simplifiedHeadwordsIdx.get(entry.simplified.headword).push(entry.index)\r\n        : this.cedict.simplifiedHeadwordsIdx.set(entry.simplified.headword, [entry.index])\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Records CEDICT data to the permanent storage.\r\n   *\r\n   * @param {object} meta - A metadata object.\r\n   * @param {object[]} dictionary - An array of dictionary records.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if data has been written successfully\r\n   *          or is reject if write operations failed.\r\n   */\r\n  _populatePermanentStorage (meta, dictionary) {\r\n    /*\r\n    `update` is used instead of `insert` here because `meta` store has only one record\r\n    and it's index must be as defined in `this.cedict.metaKey`.\r\n    Only the use of `update` allow to specify an index for the record.\r\n     */\r\n    const metaUpdate = this._storage.getStore('meta').update([meta, this.cedict.metaKey])\r\n    const dictionaryUpdate = this._storage.getStore('dictionary').insert(dictionary)\r\n    return Promise.all([metaUpdate, dictionaryUpdate])\r\n  }\r\n\r\n  /**\r\n   * Loads a single JSON file from a specified URL and decodes it.\r\n   *\r\n   * @param {string} url - A strings that specifies a URL of a JSON file\r\n   * @returns {Promise<object>|Promise<Error>} - A promise that is resolved with a JSON object or\r\n   *          rejected with the error.\r\n   */\r\n  _loadJson (url) {\r\n    return fetch(url).then(response => response.json())\r\n  }\r\n\r\n  static _getResultRecordsCount (resultsObject) {\r\n    return Object.values(resultsObject).flat().length\r\n  }\r\n}\r\n\r\n/**\r\n * Character forms that are supported with the current version of the service.\r\n *\r\n * @type {{SIMPLIFIED: string, TRADITIONAL: string}}\r\n */\r\nCedict.characterForms = {\r\n  SIMPLIFIED: 'simplified',\r\n  TRADITIONAL: 'traditional'\r\n}\r\n\r\nCedict.errMsgs = {\r\n  CONF_NO_STORAGE: 'Storage tree is missing from a configuration',\r\n  CONF_NO_STORES: 'Stores data is missing from a configuration',\r\n  CONF_NO_DICT: 'Dictionary tree is missing from a configuration',\r\n  CONF_NO_DICT_PRIMARY_IDX: 'A primaryIndex tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PRIMARY_IDX_KEY_PATH: 'A keyPath option of a primaryIndex tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE: 'A volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE_ENABLED: 'enabled option of a volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE_INDEXED: 'indexed option of a volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM: 'A permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM_ENABLED: 'enabled option of a permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM_INDEXED: 'indexed option of a permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DATA: 'Date tree is missing from a configuration',\r\n  CONF_NO_DATA_VER: 'Data version is missing from a configuration',\r\n  CONF_NO_DATA_REV: 'Data revision is missing from a configuration',\r\n  CONF_NO_DATA_REC_COUNT: 'Data records count is missing from a configuration',\r\n  CONF_NO_DATA_URI: 'Data URI is missing from a configuration',\r\n  CONF_NO_DATA_CHUNKS: 'Data chunks are missing from a configuration',\r\n  NOT_READY: 'CEDICT data is not ready',\r\n  BAD_CHAR_FORM: 'Unknown character form'\r\n}\r\n","/**\r\n * @module IndexedDbStore\r\n */\r\nimport Store from '@lexisCs/cedict-service/store.js'\r\n\r\n/**\r\n * A configuration object for IndexedDbStore must contain the following information:\r\n *\r\n * @typedef {object} IndexedDbStoreConfig\r\n * @property {string} name - A name of an IndexedDbStore instance.\r\n * @param {object} primaryIndex - An object defining configuration of a primary index.\r\n * @property {string} primaryIndex.keyPath - A name of a prop in an entry object that will serve as primary key.\r\n */\r\n\r\n/** A an IndexedDB store object */\r\nexport default class IndexedDbStore extends Store {\r\n  /**\r\n   * @param {IndexedDbStoreConfig} configuration - Configuration parameters for IndexedDbStore.\r\n   */\r\n  constructor (configuration) {\r\n    super(configuration)\r\n    this._configuration = configuration\r\n    // DB object is not available when store object is created. It must be added later.\r\n    this._db = null\r\n  }\r\n\r\n  /**\r\n   * Called by a super class to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {IndexedDbStoreConfig} configuration - Configuration parameters for IndexedDbStore.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(IndexedDbStore.errMsgs.NO_STORE_NAME)\r\n    if (!configuration.primaryIndex) throw new Error(IndexedDbStore.errMsgs.NO_PRIMARY_INDEX)\r\n    if (\r\n      !configuration.primaryIndex.hasOwnProperty('keyPath') &&\r\n      !configuration.primaryIndex.hasOwnProperty('auto')\r\n    ) throw new Error(IndexedDbStore.errMsgs.NO_PRIMARY_INDEX_PROPS)\r\n  }\r\n\r\n  /**\r\n   * Associates a store with an IndexedDB interface of a database where it is located.\r\n   *\r\n   * @param {IDBDatabase} db - An interface for connecting to IndexedDB.\r\n   * @returns {IndexedDbStore} A self-reference for chaining.\r\n   */\r\n  associateWith (db) {\r\n    this._db = db\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Disassociate a store from IndexedDB. This method is called when client is disconnected from IndexedDB.\r\n   *\r\n   * @returns {IndexedDbStore} A self-reference for chaining.\r\n   */\r\n  dissociate () {\r\n    this._db = null\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Asserts that an IndexedDbStore is associated with a database.\r\n   *\r\n   * @private\r\n   */\r\n  _assertDb () {\r\n    if (!this._db) throw new Error(IndexedDbStore.errMsgs.NO_DB)\r\n  }\r\n\r\n  /**\r\n   * Checks if store has an auto-incremented primary key\r\n   * @returns {boolean} True if primary key is auto-incremented.\r\n   * @private\r\n   */\r\n  get _isAutoPrimaryKey () {\r\n    return this._configuration.primaryIndex.hasOwnProperty('auto') && this._configuration.primaryIndex.auto\r\n  }\r\n\r\n  /**\r\n   * Returns an array of secondary index objects.\r\n   *\r\n   * @returns {object} An array of secondary index objects.\r\n   * @private\r\n   */\r\n  get _secondaryIndexes () {\r\n    return Object.values(this._configuration.indexes)\r\n  }\r\n\r\n  /**\r\n   * Returns an array of names of secondary indexes.\r\n   *\r\n   * @returns {string} An array of names of secondary indexes.\r\n   * @private\r\n   */\r\n  get _secondaryIndexNames () {\r\n    return Object.values(this._configuration.indexes).map(index => index.name)\r\n  }\r\n\r\n  /**\r\n   * Creates a store. Can be run from `onupgradeneeded` callback only.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was created successfully\r\n   *          and is rejected if creation failed.\r\n   */\r\n  create () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      const options = this._configuration.primaryIndex.keyPath ? { keyPath: this._configuration.primaryIndex.keyPath } : undefined\r\n      const store = this._db.createObjectStore(this._configuration.name, options)\r\n      if (this._configuration.indexes) {\r\n        this._secondaryIndexes.forEach(idx => {\r\n          try {\r\n            store.createIndex(idx.name, idx.keyPath, { unique: idx.unique })\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        })\r\n      }\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes all records from the store.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if all records were removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  clear () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      let transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE) // eslint-disable-line prefer-const\r\n      transaction.onerror = (event) => reject(event)\r\n      let objectStore = transaction.objectStore(this._configuration.name) // eslint-disable-line prefer-const\r\n      let clearRequest = objectStore.clear() // eslint-disable-line prefer-const\r\n      clearRequest.onsuccess = () => resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for a single key. If records do not exist, returns an empty array.\r\n   *\r\n   * @param {*} key - A key that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters:\r\n   * @param {string} options.index - If the key provided as a first argument is for a secondary index\r\n   *        then this field must contain a name of a secondary index to use. If this field is not specified,\r\n   *        then records will be retrieved using a primary index.\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  async get (key, options = {}) {\r\n    if (key === undefined) throw new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED)\r\n    return this.getEntries([key], options).then((result) => result[key])\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for one or several keys. If records do not exist, returns an empty array.\r\n   *\r\n   * @param {*|*[]} keys - A key or an array of keys that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters:\r\n   * @param {string} options.index - If the key provided as a first argument is for a secondary index\r\n   *        then this field must contain a name of a secondary index to use. If this field is not specified,\r\n   *        then records will be retrieved using a primary index.\r\n   * @returns {Promise<{key: object[] }>|Promise<Error>} A promise that is resolved with an object. If contains keys\r\n   *          as its properties and values are arrays of records.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getEntries (keys, { index = undefined } = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      if (keys === undefined) reject(new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED))\r\n      if (!Array.isArray(keys)) keys = [keys]\r\n      if (keys.length === 0) reject(new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED))\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      // Create an object with keys as its props\r\n      let result = keys.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n      /*\r\n      The order of request execution is guaranteed in IndexedDB.\r\n      This means that when the last request is completed all previous requests are done too.\r\n       */\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i]\r\n        let getRequest\r\n        if (index === undefined) {\r\n          // A secondary index is not set, we'll retrieve records by the primary index\r\n          getRequest = store.getAll(IDBKeyRange.only(key))\r\n        } else {\r\n          // Check if secondary index is valid\r\n          if (!this._secondaryIndexNames.includes(index)) throw new Error(IndexedDbStore.errMsgs.MISSING_SECONDARY_INDEX)\r\n          // Use index to retrieve a record\r\n          const dbIndex = store.index(index)\r\n          getRequest = dbIndex.getAll(IDBKeyRange.only(key))\r\n        }\r\n        getRequest.onsuccess = () => {\r\n          result[key] = getRequest.result\r\n          if (i === keys.length - 1) {\r\n            // A last request has been completed\r\n            resolve(result)\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records that exist in the store. If the store is empty returns an empty array.\r\n   *\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if store is empty.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getAllEntries () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n      transaction.onerror = (error) => { reject(error) }\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      const getRequest = store.getAll()\r\n      getRequest.onsuccess = () => {\r\n        const records = getRequest.result\r\n        resolve(records)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Inserts new records into a store. If one or several records already exist in a database\r\n   * it rejects with an error.\r\n   *\r\n   * @param {object|object[]} records - An array of records to insert.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were inserted\r\n   *          successfully and is rejected if insertion failed.\r\n   */\r\n  insert (records) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!records) { resolve() } // Do nothing\r\n      this._assertDb()\r\n      if (!Array.isArray(records)) { records = [records] }\r\n      let transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE) // eslint-disable-line prefer-const\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (event) => reject(event)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      records.forEach(record => {\r\n        let addRequest = store.add(record) // eslint-disable-line prefer-const\r\n        addRequest.onerror = () => {\r\n          if (addRequest.error.name === 'ConstraintError') {\r\n            reject(new Error(IndexedDbStore.errMsgs.DUPLICATE_RECORD))\r\n          }\r\n          reject(addRequest.error)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates records that already exist in a store.\r\n   * If a record given does not exist in a database yet it will be added there.\r\n   * TODO: with what data format does this function is expected to use most?\r\n   *\r\n   * @param {[*, object]|[[*, object]]} keyValRecordsArr - A single item or an array of items\r\n   *        to insert. Each item is an array with record as a first member and key as a second one.\r\n   *        If database does not use external keys (such as auto-incremented ones) the key value\r\n   *        will be ignored and can be omitted.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were updated\r\n   *          successfully and is rejected if operation failed.\r\n   */\r\n  update (keyValRecordsArr) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!keyValRecordsArr) resolve() // Do nothing\r\n      if (!Array.isArray(keyValRecordsArr)) reject(new Error('Records format must be [key,val] or [[key,val]]'))\r\n      if (!Array.isArray(keyValRecordsArr[0])) { keyValRecordsArr = [keyValRecordsArr] }\r\n      this._assertDb()\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE)\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (error) => reject(error)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      keyValRecordsArr.forEach(record => {\r\n        let addRequest = this._isAutoPrimaryKey ? store.put(record[0], record[1]) : store.put(record[0]) // eslint-disable-line prefer-const\r\n        addRequest.onerror = () => reject(addRequest.error)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns a total number of records in a store.\r\n   *\r\n   * @returns {Promise<number>|Promise<Error>} A promise that is resolved with number of records\r\n   *          in a store and is rejected if operation failed.\r\n   */\r\n  count () {\r\n    return new Promise((resolve) => {\r\n      this._assertDb()\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      const countRequest = store.count()\r\n      countRequest.onsuccess = () => { resolve(countRequest.result) }\r\n    })\r\n  }\r\n}\r\n\r\nIndexedDbStore.errMsgs = {\r\n  NO_DB: 'Store is not associated with a DB',\r\n  NO_STORE_NAME: 'A store name is missing from a configuration',\r\n  NO_PRIMARY_INDEX: 'A primaryIndex tree is missing from a configuration',\r\n  NO_PRIMARY_INDEX_PROPS: 'A primaryIndex tree must have either a \"keyPath\" or \"auto\" props',\r\n  NO_KEYS_PROVIDED: 'No keys are provided',\r\n  MISSING_SECONDARY_INDEX: 'Specified secondary index does not exist',\r\n  DUPLICATE_RECORD: 'Record already exists'\r\n}\r\n","import MessagingService from '@lexisCs/messaging/messaging-service.js'\r\nimport ResponseMessage from '@lexisCs/messaging/messages/response-message.js'\r\nimport Destination from '@lexisCs/messaging/destinations/window-iframe-destination.js'\r\nimport Cedict from '@lexisCs/cedict-service/cedict.js'\r\nimport CedictConfig from '@lexisCs/configurations/cedict.js'\r\nconst CedictCharacterForms = Cedict.characterForms\r\n\r\n/**\r\n * This is a configuration of a WindowsIframeDestination that can be used to connect to CEDICT client service.\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nconst CedictDestinationConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'http://data-dev.alpheios.net',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n\r\nlet cedictData\r\n\r\n/*\r\nNOTE: The request/response format described below is temporary and will change in phase three.\r\nAfter discussion we decided to add more flexibility for the client in specifying what data it wants to get back.\r\n\r\nCEDICT service receive request in the following format:\r\n{\r\n  getWords: {\r\n    words: words,\r\n    characterForm: characterForm\r\n  }\r\n}, where:\r\n  getWords is a type of incoming request;\r\n  words contains an array of words to retrieve;\r\n  characterForm specifies a Chinese character form that will be used during lookups.\r\n  If character form is not known, it can be omitted. In that case CEDICT service will\r\n  check records for traditional Chinese first and, if any matches are found, will return it back.\r\n  If nothing is found within a traditional Chinese, it will look in a simplified one.\r\n  Results for only one character form or no results at all, if no matches are found, will be returned.\r\n\r\nResults will be returned in the following format.\r\n\r\nIf any matches are found:\r\n{\r\n    characterForm: {\r\n        word1: [array of records],\r\n        word2: [an empty array if no records are found for this word]\r\n    }\r\n}\r\n\r\nIf no matches are found an empty object will be returned:\r\n{}\r\n */\r\n\r\nconst messageHandler = (request, responseFn) => {\r\n  if (!cedictData.isReady) {\r\n    responseFn(ResponseMessage.Error(request, new Error('Uninitialized')))\r\n    return\r\n  }\r\n\r\n  if (request.body.getWords) {\r\n    // This is a get words request\r\n    cedictData.getWords(request.body.getWords.words, request.body.getWords.characterForm)\r\n      .then((result) => {\r\n        responseFn(ResponseMessage.Success(request, result))\r\n      }).catch((error) => responseFn(ResponseMessage.Error(request, error)))\r\n  } else {\r\n    responseFn(ResponseMessage.Error(request, new Error('Unsupported request')))\r\n  }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  const service = new MessagingService(new Destination(CedictDestinationConfig))\r\n  service.registerReceiverCallback(CedictDestinationConfig.name, messageHandler)\r\n\r\n  try {\r\n    cedictData = new Cedict(CedictConfig)\r\n  } catch (error) {\r\n    console.error(error)\r\n    return\r\n  }\r\n  cedictData.init().then(() => {\r\n    // TODO: A message to ease manual testing. Shall be removed in production\r\n    console.log('CEDICT service is ready')\r\n  }).catch((error) => console.error(error))\r\n})\r\n\r\nexport { CedictDestinationConfig, CedictCharacterForms }\r\n","/**\r\n * @module Storage\r\n */\r\n\r\n/** A base class for data storage. Storage is a container of several stores (e.g. a database with several tables) */\r\nexport default class Storage {\r\n  constructor (configuration) {\r\n    this.constructor._checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n  }\r\n\r\n  /**\r\n   * An internal method to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(Storage.errMsgs.CONF_NO_NAME)\r\n    if (!configuration.version) throw new Error(Storage.errMsgs.CONF_NO_VER)\r\n  }\r\n\r\n  /**\r\n   * Create a storage and all the stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all stores were created successfully or is rejected if operations fails.\r\n   */\r\n  create () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Destroys a storage and all the stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all stores were destroyed successfully or is rejected if operations fails.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Establishes a connection to the storage. It, if necessary, initializes a storage and stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          established successfully or is rejected if connection fails.\r\n   */\r\n  connect () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Disconnects from the storage.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          closed successfully or is rejected if operations fails.\r\n   */\r\n  disconnect () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns information to verify storage integrity. A set of integrity data is specific for each particular\r\n   * storage type so each storage implementation must define this function on its own.\r\n   *\r\n   * @returns {Promise<{object}>|Promise<Error>}\r\n   *          Returns a promise that is resolved with an object with storage integrity information or is rejected\r\n   *          if storage integrity is broken.\r\n   */\r\n  getIntegrityData () {\r\n    return new Promise((resolve) => {\r\n      resolve({})\r\n    })\r\n  }\r\n}\r\n\r\nStorage.errMsgs = {\r\n  CONF_NO_NAME: 'Storage name is missing from a configuration',\r\n  CONF_NO_VER: 'Storage version is missing from a configuration'\r\n}\r\n","/**\r\n * @module Store\r\n */\r\n\r\n/**\r\n * A configuration object for Store must contain the following information:\r\n *\r\n * @typedef {object} StoreConfig\r\n * @property {string} name - A name of a store.\r\n */\r\n\r\n/** A base class for data stores */\r\nexport default class Store {\r\n  /**\r\n   * @param {StoreConfig} configuration - An object with configuration parameters.\r\n   */\r\n  constructor (configuration) {\r\n    this.constructor._checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n  }\r\n\r\n  /**\r\n   * Called internally to check if the configuration supplied has all the information necessary in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {StoreConfig} configuration - An object with configuration parameters.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(Store.errMsgs.CONF_NO_NAME)\r\n  }\r\n\r\n  /**\r\n   * Associates a store with a container where it exists: a remote storage, an IndexedDB, etc.\r\n   *\r\n   * @param {object} storeObject - A store object.\r\n   * @returns {Store} A self-reference for chaining.\r\n   */\r\n  associateWith (storeObject) {\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a store. Can be run from `onupgradeneeded` callback only.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was created successfully\r\n   *          and is rejected if creation failed.\r\n   */\r\n  create () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes all records from the store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if all records were removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  clear () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes a store from its container.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for a single key. Options object is implementation specific.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {*} key - A key that specifies which records to retrieve.\r\n   * @param {object} options - Additional configuration parameters.\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  get (key, options) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for one or several keys. Options object is implementation specific.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {*|*[]} keys - A key or an array of keys that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters.\r\n   * @returns {Promise<{key: object[]}>|Promise<Error>} A promise that is resolved with an object. If contains keys\r\n   *          as its properties and values are arrays of records.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getEntries (keys, { index = '' } = {}) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records that exist in the store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  getAllEntries () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Inserts new records into a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {object[]} records - An array of records to insert.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were inserted\r\n   *          successfully and is rejected if insertion failed.\r\n   */\r\n  insert (records) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates records that already exist in a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {[any, object]|[[any, object]]} keyValRecordsArr - A single item or an array of items\r\n   *        to insert. Each item is an array with key as a first member and a record to insert as a second one.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were updated\r\n   *          successfully and is rejected if operation failed.\r\n   */\r\n  update (keyValRecordsArr) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns a total number of records in a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<number>|Promise<Error>} A promise that is resolved with number of records\r\n   *          in a store and is rejected if operation failed.\r\n   */\r\n  count () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n}\r\n\r\nStore.accessModes = {\r\n  READ: 'readonly',\r\n  READ_WRITE: 'readwrite'\r\n}\r\n\r\nStore.errMsgs = {\r\n  CONF_NO_NAME: 'A store name is missing from a configuration'\r\n}\r\n","/*\r\nThis object defines a configuration of a CEDICT service. We could have several configuration\r\nfiles each targeted for a specific platform or purpose and specify a proper configuration\r\nupon the service initialization.\r\n */\r\nconst cedict = {\r\n  /*\r\n  An information about how CEDICT data is stored within the CEDICT service.\r\n   */\r\n  storage: {\r\n    name: 'cedict',\r\n    /*\r\n    Version defines a configuration of a storage schema, e.g. what tables are used to store data,\r\n    what fields do they have, etc.\r\n     */\r\n    version: 1,\r\n    stores: {\r\n      /*\r\n      A store to keep metadata about a dictionary. It will have only one entry with the metadata object.\r\n       */\r\n      meta: {\r\n        name: 'meta',\r\n        primaryIndex: {\r\n          auto: true\r\n        }\r\n      },\r\n\r\n      /*\r\n      This is a store that keeps dictionary entries themselves.\r\n       */\r\n      dictionary: {\r\n        name: 'dictionary',\r\n        primaryIndex: {\r\n          /*\r\n          What property of a dictionary entry will become a primary index.\r\n           */\r\n          keyPath: 'index'\r\n        },\r\n\r\n        /*\r\n        The following defines the secondary indexes. The name of an index is used to address it\r\n        during queries. keyPath defines what prop of a dictionary entry will be used to build an index.\r\n         */\r\n        indexes: {\r\n          traditional: {\r\n            name: 'traditionalHwIdx',\r\n            keyPath: 'traditional.headword',\r\n            unique: false\r\n          },\r\n          simplified: {\r\n            name: 'simplifiedHwIdx',\r\n            keyPath: 'simplified.headword',\r\n            unique: false\r\n          }\r\n        },\r\n        volatileStorage: {\r\n          /*\r\n          If volatile storage is disabled, all queries will run against an IndexedDB. This will minimize\r\n          RAM usage and is fast enough for most purposes (from several to tens of milliseconds). Enabling\r\n          volatile storage will place data into RAM and data will be retrieved faster at cost of a higher\r\n          RAM usage.\r\n           */\r\n          enabled: false,\r\n\r\n          /*\r\n          If volatile storage is indexed it will create additional in-memory maps to store headword indexes.\r\n          It will result in almost instantaneous retrieval of data at cost of a higher RAM usage.\r\n           */\r\n          indexed: false\r\n        },\r\n        permanentStorage: {\r\n          /*\r\n          With permanents storage enabled all CEDICT data will be saved into an IndexedDB and will stay there\r\n          between page reloads. This will allow not to download all CEDICT data each time the CEDICT service\r\n          is started. It will decrease a service start time significantly (by tens of seconds, usually).It\r\n          will also spare several megabytes of network traffic.\r\n\r\n          With permanent storage enabled clients will be able to run searches directly against an IndexedDB\r\n          thus keeping RAM usage at a minimum.\r\n\r\n          It is highly recommended to have permanent storage always enabled except for cases when\r\n          a target device does not support it.\r\n\r\n          Please note: even if permanent storage is disabled, it will still be created in order to\r\n          put downloaded data into it and to avoid downloading it again with each service initialization.\r\n           */\r\n          enabled: true,\r\n\r\n          /*\r\n          (Currently not implemented.)\r\n          Disabling permanent store indexes will slow searches down significantly (up to more than a second).\r\n          On the other hand, having indexes enabled to not increase IndexedDB size significantly.\r\n          Because of that it is recommended to always have this option on.\r\n           */\r\n          indexed: true\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /*\r\n  Describes CEDICT data on a remote server that is required to run the current version of CEDICT service.\r\n   */\r\n  data: {\r\n    /*\r\n    The date when CEDICT data was last edited.\r\n     */\r\n    version: 20191029,\r\n\r\n    /*\r\n    If data will be updated more than once a day revision will increment with each edition.\r\n     */\r\n    revision: 1,\r\n\r\n    /*\r\n    Number of records in the current CEDICT edition. It is used for integrity checking.\r\n     */\r\n    recordsCount: 117735,\r\n\r\n    /*\r\n    A URI where chunks of CEDICT data are located.\r\n     */\r\n    URI: 'http://data-dev.alpheios.net/cedict',\r\n\r\n    /*\r\n    Names of the chunks themselves.\r\n     */\r\n    chunks: [\r\n      'cedict-v20191029-c001.json',\r\n      'cedict-v20191029-c002.json',\r\n      'cedict-v20191029-c003.json',\r\n      'cedict-v20191029-c004.json',\r\n      'cedict-v20191029-c005.json'\r\n    ]\r\n  }\r\n}\r\n\r\nexport default cedict\r\n","/**\r\n * @module Destination\r\n */\r\n\r\n/** Destination represents a place where messages are sent to and are received from (e.g. a windows) */\r\nexport default class Destination {\r\n  /**\r\n   * Creates an instance of a Destination object. Descendants may take configuration parameters through\r\n   * a second argument that they can define.\r\n   *\r\n   * @param {object} [configuration={}] - A configuration object for a destination.\r\n   * @param {string} configuration.name - A name of a particular destination.\r\n   */\r\n  constructor ({ name } = {}) {\r\n    if (!name) {\r\n      throw new Error('Destination name is missing')\r\n    }\r\n\r\n    /**\r\n     * A name of a destination. Used to refer to it within a messaging service.\r\n     *\r\n     * @type {string}\r\n     * @public\r\n     */\r\n    this.name = name\r\n\r\n    /**\r\n     * A function that will be called when a response from destination is received.\r\n     *\r\n     * @type {Function}\r\n     * @private\r\n     */\r\n    this._responseCallback = null\r\n  }\r\n\r\n  /**\r\n   * Registers a function to call when a response from destination is received.\r\n   *\r\n   * @param {Function} callbackFn - A function to be called when response is received.\r\n   */\r\n  registerResponseCallback (callbackFn) {\r\n    this._responseCallback = callbackFn\r\n  }\r\n}\r\n","/**\r\n * @module WindowIframeDestination\r\n */\r\nimport Destination from '@lexisCs/messaging/destinations/destination.js'\r\n\r\n/** WindowIframeDestination represents a content window within an iframe */\r\nexport default class WindowIframeDestination extends Destination {\r\n  /**\r\n   * @param {object} [configuration={}] - An object containing configuration parameters.\r\n   * @param {string} configuration.name - A name of a destination (for addressing a destination in a messaging service).\r\n   * @param {string} configuration.targetURL - A URL of a document within an iframe where messages will be sent.\r\n   * @param {string} configuration.targetIframeID - An ID of an iframe element (without `#`).\r\n   */\r\n  constructor ({ name, targetURL, targetIframeID } = {}) {\r\n    super({ name })\r\n\r\n    if (!targetURL) {\r\n      throw new Error('Target URL is not provided')\r\n    }\r\n\r\n    if (!targetIframeID) {\r\n      throw new Error('Target iframe ID is not provided')\r\n    }\r\n\r\n    /**\r\n     * A URL of a document within an iframe where messages will be sent.\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetURL = targetURL\r\n\r\n    /**\r\n     * An ID of an iframe element (without `#`).\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetIframeID = targetIframeID\r\n\r\n    window.addEventListener('message', this._responseHandler.bind(this), false)\r\n  }\r\n\r\n  /**\r\n   * Registers a function to be called an a receiving side when a message from origin to destination will arrive.\r\n   * This callback will receive the following arguments: the request object (of `RequestMessage` type)\r\n   * and the function that can be used to send a response.\r\n   *\r\n   * @param {Function} callbackFn - A function that will be called when a request will arrive to its destination.\r\n   */\r\n  registerReceiverCallback (callbackFn) {\r\n    window.addEventListener('message', this._requestHandler.bind(this, callbackFn), false)\r\n  }\r\n\r\n  /**\r\n   * A function that will be called to send a request from origin to destination.\r\n   *\r\n   * @param {RequestMessage} requestMessage - A request message object.\r\n   */\r\n  sendRequest (requestMessage) {\r\n    const iframe = document.querySelector(`#${this._targetIframeID}`)\r\n    if (!iframe) {\r\n      throw new Error(`An #${this._targetIframeID} iframe does not exist in the document`)\r\n    }\r\n    const iframeWindow = iframe.contentWindow\r\n    iframeWindow.postMessage(requestMessage, this._targetURL)\r\n  }\r\n\r\n  /**\r\n   * A function that is used to send a response from destination to origin.\r\n   *\r\n   * @param {ResponseMessage} responseMessage - A response message object.\r\n   */\r\n  sendResponse (responseMessage) {\r\n    window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when request arrives to its destination.\r\n   *\r\n   * @param {Function} callbackFn - A client's callback function that will be called and\r\n   *                                passed a request (a `RequestMessage` object).\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _requestHandler (callbackFn, event) {\r\n    // `data` prop of an event contains a request message object\r\n    let request = event.data // eslint-disable-line prefer-const\r\n    request.header.origin = event.origin\r\n    callbackFn(request, this.sendResponse.bind(this))\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when response arrives from destination to origin.\r\n   *\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _responseHandler (event) {\r\n    if (event.origin !== this._targetURL) {\r\n      // Message came from a destination we're not listening for\r\n      return\r\n    }\r\n\r\n    // `data` prop of an event contains a response message object\r\n    const responseMessage = event.data\r\n    if (this._responseCallback) {\r\n      this._responseCallback(responseMessage)\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @module Message\r\n */\r\nimport uuidv4 from 'uuid/v4'\r\n\r\n/** A base class for all types of messages */\r\nexport default class Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    /**\r\n     * A message's role (@see {@link Message.roles}). Will be defined in descendants.\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.role = undefined\r\n\r\n    /**\r\n     * A type of the message. Used to distinguish one kind of message from the other (@see {@link Message.types}).\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.type = Message.types.GENERIC\r\n\r\n    /**\r\n     * A unique identifier of the message.\r\n     *\r\n     * @type {string}\r\n     */\r\n    this.ID = uuidv4()\r\n\r\n    /**\r\n     * An object with no methods representing a message body.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.body = body\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a message is request or response.\r\n */\r\nMessage.roles = {\r\n  REQUEST: 'Request',\r\n  RESPONSE: 'Response'\r\n}\r\n\r\n/**\r\n * Specifies a message type: what kind of message it is and what purpose it serves.\r\n */\r\nMessage.types = {\r\n  GENERIC: 'Generic'\r\n}\r\n","/**\r\n * @module RequestMessage\r\n */\r\nimport Message from './message.js'\r\n\r\n/** A request message */\r\nexport default class RequestMessage extends Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    super(body)\r\n    this.role = Message.roles.REQUEST\r\n\r\n    /**\r\n     * A message header. Will contain routing information usually.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.header = {}\r\n  }\r\n}\r\n","/**\r\n * @module ResponseMessage\r\n */\r\nimport Message from '@lexisCs/messaging/messages/message.js'\r\nimport RequestMessage from '@lexisCs/messaging/messages/request-message.js'\r\n\r\n/** A response message that is sent as an answer to the request message. */\r\nexport default class ResponseMessage extends Message {\r\n  /**\r\n   * @param {RequestMessage} request - A request that initiated this response. Used to copy routing information mostly.\r\n   * @param {object} [body={}] - A body of the response, a plain JS object with no methods.\r\n   * @param {string} responseCode - A code to indicate results of the request handling: Success, Failure, etc.\r\n   */\r\n  constructor (request, body = {}, responseCode = ResponseMessage.responseCodes.UNDEFINED) {\r\n    super(body)\r\n    if (!request) throw new Error('Request is not provided')\r\n    if (!request.ID) throw new Error('Request has no ID')\r\n    this.role = Message.roles.RESPONSE\r\n    this.requestHeader = request.header || {}\r\n    this.requestID = request.ID // ID of the request to match request and response\r\n    this.responseCode = responseCode\r\n  }\r\n\r\n  /**\r\n   * A builder for a response message with a SUCCESS response code.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {object} [body={}] - A body of response message.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Success (request, body = {}) {\r\n    return new this(request, body, ResponseMessage.responseCodes.SUCCESS)\r\n  }\r\n\r\n  /**\r\n   * A builder for a message with an ERROR response code. Error information will be sent within the message body.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {Error} error - An error object containing error information.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Error (request, error) {\r\n    return new this(request, error, ResponseMessage.responseCodes.ERROR)\r\n  }\r\n\r\n  /**\r\n   * Checks if this message is a response (i.e. if it follows a response message format and conventions).\r\n   *\r\n   * @param {RequestMessage | ResponseMessage} message - A request or response message to be tested.\r\n   * @returns {boolean} - True if the message is a response, false otherwise.\r\n   */\r\n  static isResponse (message) {\r\n    return message.role &&\r\n      message.role === Message.roles.RESPONSE &&\r\n      message.requestHeader &&\r\n      message.requestID\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a request was processed successfully or not.\r\n */\r\nResponseMessage.responseCodes = {\r\n  // Request was processed successfully.\r\n  // In this case a message body may contain a response data object or be empty.\r\n  SUCCESS: 'Success',\r\n\r\n  // There is no information about what was the outcome of request.\r\n  UNDEFINED: 'Undefined',\r\n\r\n  // Request failed. A message body will have information about an error.\r\n  ERROR: 'Error'\r\n}\r\n","/**\r\n * @module MessagingService\r\n */\r\nimport ResponseMessage from './messages/response-message'\r\nimport StoredRequest from './stored-request'\r\n\r\n/** A messaging for sending and receiving messages to and from various destinations */\r\nexport default class MessagingService {\r\n  constructor (destinations = []) {\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is the message ID and the value is an object\r\n     * that stores details about the message being sent.\r\n     *\r\n     * @type {Map<string, StoredRequest>}\r\n     */\r\n    this._messages = new Map()\r\n\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is a destination name and the value is\r\n     * the Destination object.\r\n     *\r\n     * @type {Map<string, Destination>}\r\n     */\r\n    this._destinations = new Map()\r\n\r\n    // If provided as a singular value convert destination into an array\r\n    if (!Array.isArray(destinations)) { destinations = [destinations] }\r\n    destinations.forEach(destination => this.registerDestination(destination))\r\n  }\r\n\r\n  /**\r\n   * Registers a new destination by adding it to the destinations map and setting a response callback.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  registerDestination (destination) {\r\n    if (this._destinations.has(destination.name)) {\r\n      throw new Error('Destination already exists')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    destination.registerResponseCallback(this.dispatchMessage.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Updates a destinations that is already registered.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  updateDestination (destination) {\r\n    if (!this._destinations.has(destination.name)) {\r\n      throw new Error('Cannot update a destination that does not exist')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    destination.registerResponseCallback(this.dispatchMessage.bind(this))\r\n  }\r\n\r\n  /**\r\n   * A function to handle incoming messages.\r\n   *\r\n   * @param {ResponseMessage} message - An incoming response message.\r\n   */\r\n  dispatchMessage (message) {\r\n    if (!ResponseMessage.isResponse(message)) {\r\n      console.error('A message not following a response format will be ignored:', message)\r\n      return\r\n    }\r\n\r\n    if (!this._messages.has(message.requestID)) {\r\n      console.error(`Ignoring a message with request ID ${message.requestID} not registered in a request list`, message)\r\n      return\r\n    }\r\n    const requestInfo = this._messages.get(message.requestID)\r\n    window.clearTimeout(requestInfo.timeoutID) // Clear a timeout\r\n    const responseCode = message.responseCode\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // There was an error returned. An error info is in the message body.\r\n      requestInfo.reject(message.body)\r\n    } else {\r\n      // Request was processed without errors\r\n      requestInfo.resolve(message)\r\n    }\r\n    this._messages.delete(message.requestID) // Remove request info from the map\r\n  }\r\n\r\n  /**\r\n   * Registers an outgoing request within a request map. Returns a promise that will be fulfilled when\r\n   * a response will be received or rejected when a timeout will expire.\r\n   *\r\n   * @param {RequestMessage} request - An outgoing request.\r\n   * @param {number} timeout - A number of milliseconds we'll wait for response before rejecting a promise.\r\n   * @returns {Promise} - A promise that will be resolved with the message response or rejected with an error info.\r\n   */\r\n  registerRequest (request, timeout = 10000) {\r\n    if (this._messages.has(request.ID)) throw new Error(`Request with ${request.ID} ID is already registered`)\r\n    let storedRequest = new StoredRequest(request) // eslint-disable-line prefer-const\r\n    this._messages.set(request.ID, storedRequest)\r\n    storedRequest.timeoutID = window.setTimeout((requestID) => {\r\n      storedRequest.reject(new Error(`Timeout has been expired for a message with request ID ${request.ID}`))\r\n      this._messages.delete(requestID) // Remove request record from the map\r\n    }, timeout)\r\n    return storedRequest.promise\r\n  }\r\n\r\n  /**\r\n   * Sends a request message to a specific destination.\r\n   *\r\n   * @param {string} destName - A name of a destination where request will be sent to.\r\n   * @param {RequestMessage} request - A request message to be sent.\r\n   * @param {number} timeout - How many milliseconds to wait for a response.\r\n   * @returns {Promise<ResponseMessage> | Promise<Error> | Promise<object>} - A promise either resolved\r\n   *          with response message or rejected with the error info.\r\n   */\r\n  sendRequestTo (destName, request, timeout = 10000) {\r\n    if (!destName) {\r\n      throw new Error('Destination name is not provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    const promise = this.registerRequest(request, timeout)\r\n    this._destinations.get(destName).sendRequest(request)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Sets a function to be called on a destination side every time a message from the origin arrives.\r\n   *\r\n   * @param {string} destName - A name of a destination to listen to messages from.\r\n   * @param {Function} callbackFn - A function to call when message is arrived. A message will be passed\r\n   *                                to this function as an argument.\r\n   */\r\n  registerReceiverCallback (destName, callbackFn) {\r\n    if (!destName) {\r\n      throw new Error('No destination name provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    this._destinations.get(destName).registerReceiverCallback(callbackFn)\r\n  }\r\n}\r\n","/**\r\n * @module StoredRequest\r\n */\r\n\r\n/** Stores information about request being sent via the messaging service */\r\nexport default class StoredRequest {\r\n  constructor () {\r\n    /**\r\n     * A function to resolve the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.resolve = null\r\n\r\n    /**\r\n     * A function to reject the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.reject = null\r\n\r\n    // A promise that will be resolved or rejected when the response will arrive or the timeout will expire\r\n    this.promise = new Promise(this.executor.bind(this))\r\n  }\r\n\r\n  executor (resolve, reject) {\r\n    this.resolve = resolve\r\n    this.reject = reject\r\n  }\r\n}\r\n"],"sourceRoot":""}