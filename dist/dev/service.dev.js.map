{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:////webpack/universalModuleDefinition","webpack:////webpack/bootstrap","webpack:////index.js","webpack:////node_modules/uuid/dist/esm-browser/bytesToUuid.js","webpack:////node_modules/uuid/dist/esm-browser/index.js","webpack:////node_modules/uuid/dist/esm-browser/md5.js","webpack:////node_modules/uuid/dist/esm-browser/rng.js","webpack:////node_modules/uuid/dist/esm-browser/sha1.js","webpack:////node_modules/uuid/dist/esm-browser/v1.js","webpack:////node_modules/uuid/dist/esm-browser/v3.js","webpack:////node_modules/uuid/dist/esm-browser/v35.js","webpack:////node_modules/uuid/dist/esm-browser/v4.js","webpack:////node_modules/uuid/dist/esm-browser/v5.js","webpack:////src/configurations/destinations.js","webpack:////src/core/messaging-service.js","webpack:////src/core/stored-request.js","webpack:////src/destinations/destination.js","webpack:////src/destinations/window-iframe-destination.js","webpack:////src/messages/message.js","webpack:////src/messages/request-message.js","webpack:////src/messages/response-message.js","webpack:///./src/cedict-service/cedict-permanent-storage.js","webpack:///./src/cedict-service/cedict.js","webpack:///./src/cedict-service/constants.js","webpack:///./src/cedict-service/indexed-db-store.js","webpack:///./src/cedict-service/service.js","webpack:///./src/cedict-service/storage.js","webpack:///./src/cedict-service/store.js","webpack:///./src/configurations/cedict.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,aAKJ;AACF,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACuB;AACvB;AACE;AAC0C;;AAK7G;;;;;;;;;;;;;ACTD;AAAA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEe,0EAAW,E;;;;;;;;;;;;ACjB1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACA;AACA;;;;;;;;;;;;;ACFxC;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,aAAa,mBAAmB;AAChC;AACA;;AAEA;;AAEA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,kEAAG,E;;;;;;;;;;;;ACzNlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAEhB;AACf;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACdA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;AC1FnB;AAAA;AAAA;AAA2B;AACgB;AAC3C;AACA;AACA;;AAEA;;AAEA,cAAc;;;AAGd;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;;AAEA;AACA,sDAAsD,+CAAG;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA,iFAAiF;AACjF;;AAEA,2EAA2E;;AAE3E,6DAA6D;;AAE7D;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,sBAAsB;;AAEtB,mCAAmC;;AAEnC,6BAA6B;;AAE7B,iCAAiC;;AAEjC,2BAA2B;;AAE3B,iBAAiB,OAAO;AACxB;AACA;;AAEA,qBAAqB,+DAAW;AAChC;;AAEe,iEAAE,E;;;;;;;;;;;;AC9FjB;AAAA;AAAA;AAA2B;AACA;AAC3B,SAAS,uDAAG,aAAa,+CAAG;AACb,iEAAE,E;;;;;;;;;;;;ACHjB;AAAA;AAAA;AAAA;AAA2C;;AAE3C;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA,GAAG;AACH;AACA;;AAEA;AACA,0CAA0C;;AAE1C;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEO;AACA;AACQ;AACf;AACA;AACA;AACA;AACA;AACA,6IAA6I;;AAE7I;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA,kBAAkB,+DAAW;AAC7B,IAAI;;;AAGJ;AACA;AACA,GAAG,eAAe;;;AAGlB;AACA;AACA;AACA,C;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAA2B;AACgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,+CAAG,IAAI;;AAEtD;AACA,kCAAkC;;AAElC;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA,gBAAgB,+DAAW;AAC3B;;AAEe,iEAAE,E;;;;;;;;;;;;AC1BjB;AAAA;AAAA;AAA2B;AACE;AAC7B,SAAS,uDAAG,aAAa,gDAAI;AACd,iEAAE,E;;;;;;;;;;;;ACHjB;AAAA;AAAA;AAAA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACiB;AACR;;AAE5D;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,0BAA0B;AACvC;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,SAAS,qEAAO;AAChB;AACA;AACA;AACA,SAAS,8EAAe;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,8EAAe;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA,wEAAwE,WAAW;AACnF,4BAA4B,wEAAa;AACzC;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA,KAAK;AACL,oCAAoC,SAAS,WAAW,YAAY;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChNA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA,gBAAgB,iDAAiD,KAAK;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACY;;AAE/D;AACe,sCAAsC,6EAAW;AAChE;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,gBAAgB,yDAAyD,KAAK;AAC9E,WAAW,kBAAkB;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6DAA6D,qEAAO;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AACA;AACA;AACmC;;AAEnC;AACe;AACf;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,+BAA+B,oBAAoB;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA,4FAA4F,oBAAoB;AAChH;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,+CAAM;;AAEpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;;AAEnD;AACe,6BAA6B,qEAAO;AACnD;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,gBAAgB,qEAAO;;AAEvB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACe;;AAElE;AACe,8BAA8B,qEAAO;AACpD;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,iCAAiC,2DAA2D,YAAY,KAAK;AAC7G;AACA;AACA;AACA,gBAAgB,qEAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,eAAe,gBAAgB;AAC/B;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,0EAA0E,YAAY;AACtF;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,QAAQ;AACvB;AACA;AACA;AACA,uBAAuB,qEAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACwD;AACgB;;AAExE;AACe,qCAAqC,0EAAO;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC,mFAAc,gBAAgB;AACrG;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS,WAAW,OAAO,kBAAkB,OAAO,wBAAwB,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC;AACvC,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAC2E;AACa;;AAExF;AACe;AACf;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,wBAAwB,2FAAsB;;AAE9C;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yFAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA,iCAAiC,yFAAoB;AACrD;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,2BAA2B,gBAAgB;AAC3C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,oCAAoC,yFAAoB;AACxD;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,iBAAiB;AAC9B;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8FAA8F,6BAA6B,IAAI,cAAc;AAC7I;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAyC;AAChE,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2EAA2E,wCAAwC;AACnH;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,2EAA2E,2BAA2B;AACtG;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,yDAAyD,uBAAuB,qBAAqB,IAAI;AACzG;AACA;AACA;AACA;AACA,2CAA2C,yFAAoB;AAC/D;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,0CAA0C,yFAAoB;AAC9D;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA,qCAAqC,yFAAoB;AACzD,mEAAmE,QAAQ;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,mCAAmC,mBAAmB;AAC9E;AACA;AACA;AACA,oFAAoF,6BAA6B,GAAG,MAAM;AAC1H;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChgBA;AAAA;AAAA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACoD;;AAEpD;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,WAAW,OAAO;AAClB,cAAc,OAAO;AACrB;;AAEA;AACe,6BAA6B,wEAAK;AACjD;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,kEAAkE,oDAAoD;AACtH;AACA;AACA;AACA;AACA,sDAAsD,qBAAqB;AAC3E,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO,YAAY;AAChC,aAAa,OAAO;AACpB;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO,YAAY;AAChC,aAAa,OAAO;AACpB;AACA;AACA,eAAe,SAAS,eAAe,iBAAiB;AACxD;AACA;AACA;AACA,qBAAqB,oBAAoB,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB,qBAAqB,IAAI;AACtG;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuI;AAC5D;AACrB;AACM;;AAE5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAe,oBAAoB;AACtD,OAAO;AACP,6DAA6D,YAAY;AACzE,mBAAmB,kEAAe,mDAAmD,kEAAe;AACpG;AACA,KAAK;AACL;AACA,iBAAiB,kEAAe,oBAAoB;AACpD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,iBAAiB,kEAAe,4CAA4C,kEAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,kEAAe;AAClC,OAAO,8BAA8B,kEAAe,uBAAuB,kEAAe;AAC1F,GAAG;AACH,eAAe,kEAAe,kDAAkD,kEAAe;AAC/F;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAgB;AACtC;AACA,QAAQ,0EAAW,EAAE,IAAI,0EAAuB,cAAc,0EAAW,iDAAiD;AAC1H;;AAEA;AACA,qBAAqB,yEAAM,CAAC,yEAAY;AACxC,GAAG;AACH;AACA;AACA,CAAC;;AAEuD;;;;;;;;;;;;;AChHxD;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACe;AACf;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO,YAAY;AAChC,eAAe,SAAS,cAAc,iBAAiB;AACvD;AACA;AACA;AACA,qBAAqB,aAAa,KAAK;AACvC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/KA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM","file":"service.dev.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/cedict-service/service.js\");\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import MessagingService from '@messServ/core/messaging-service.js'\r\nimport WindowIframeDestination from '@messServ/destinations/window-iframe-destination.js'\r\nimport RequestMessage from '@messServ/messages/request-message.js'\r\nimport ResponseMessage from '@messServ/messages/response-message.js'\r\nimport { CedictDestinationConfig, CedictDestinationDevConfig } from '@messServ/configurations/destinations.js'\r\n\r\nexport {\r\n  MessagingService, WindowIframeDestination, RequestMessage, ResponseMessage,\r\n  CedictDestinationConfig, CedictDestinationDevConfig\r\n}\r\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes == 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Array(msg.length);\n\n    for (var i = 0; i < msg.length; i++) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var i;\n  var x;\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n  var hex;\n\n  for (i = 0; i < length32; i += 8) {\n    x = input[i >> 5] >>> i % 32 & 0xff;\n    hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[(len + 64 >>> 9 << 4) + 14] = len;\n  var i;\n  var olda;\n  var oldb;\n  var oldc;\n  var oldd;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (i = 0; i < x.length; i += 16) {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  var i;\n  var output = [];\n  output[(input.length >> 2) - 1] = undefined;\n\n  for (i = 0; i < output.length; i += 1) {\n    output[i] = 0;\n  }\n\n  var length8 = input.length * 8;\n\n  for (i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes == 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Array(msg.length);\n\n    for (var i = 0; i < msg.length; i++) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var i = 0; i < N; i++) {\n    M[i] = new Array(16);\n\n    for (var j = 0; j < 16; j++) {\n      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var i = 0; i < N; i++) {\n    var W = new Array(80);\n\n    for (var t = 0; t < 16; t++) {\n      W[t] = M[i][t];\n    }\n\n    for (var t = 16; t < 80; t++) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var t = 0; t < 80; t++) {\n      var s = Math.floor(t / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","import bytesToUuid from './bytesToUuid.js';\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  var bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = new Array(str.length);\n\n  for (var i = 0; i < str.length; i++) {\n    bytes[i] = str.charCodeAt(i);\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  var generateUUID = function generateUUID(value, namespace, buf, offset) {\n    var off = buf && offset || 0;\n    if (typeof value == 'string') value = stringToBytes(value);\n    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);\n    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');\n    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3\n\n    var bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      for (var idx = 0; idx < 16; ++idx) {\n        buf[off + idx] = bytes[idx];\n      }\n    }\n\n    return buf || bytesToUuid(bytes);\n  }; // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name;\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","/**\r\n * This is a configuration of a WindowsIframeDestination that can be used to connect to CEDICT client service.\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nexport const CedictDestinationConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'https://lexis-dev.alpheios.net',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n/**\r\n * This is a development version of the above configuration\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nexport const CedictDestinationDevConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'https://lexis-dev.alpheios.net/index-dev.html',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n","/**\r\n * @module MessagingService\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport ResponseMessage from '@messServ/messages/response-message.js'\r\nimport StoredRequest from '@messServ/core/stored-request.js'\r\n\r\n/**\r\n * A map to keep \"single\" instances of MessagingService objects.\r\n *\r\n * @type {Map<string, MessagingService>}\r\n */\r\nlet services = new Map() // eslint-disable-line prefer-const\r\n\r\n/** A messaging for sending and receiving messages to and from various destinations */\r\nexport default class MessagingService {\r\n  /**\r\n   * Creates an instance of a messaging service.\r\n   *\r\n   * @param {string} name - A name of a messaging service. Useful in identifying the service when\r\n   *        several clients need to share the same instance of a service.\r\n   * @param {Destination || Destination[]} destinations - One or several\r\n   *        destination objects to be used with the messaging service.\r\n   */\r\n  constructor (name, destinations = []) {\r\n    if (!name) throw new Error(MessagingService.errMsgs.NO_NAME)\r\n    this.name = name\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is the message ID and the value is an object\r\n     * that stores details about the message being sent.\r\n     *\r\n     * @type {Map<string, StoredRequest>}\r\n     */\r\n    this._messages = new Map()\r\n\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is a destination name and the value is\r\n     * the Destination object.\r\n     *\r\n     * @type {Map<string, Destination>}\r\n     */\r\n    this._destinations = new Map()\r\n\r\n    // If provided as a singular value convert destination into an array\r\n    if (!Array.isArray(destinations)) { destinations = [destinations] }\r\n    destinations.forEach(destination => this.registerDestination(destination))\r\n  }\r\n\r\n  /**\r\n   * Check if service with a given name has already been created.\r\n   *\r\n   * @param {string} name - A name of a service.\r\n   * @returns {boolean} Returns true if service has already been created or false otherwise.\r\n   */\r\n  static hasService (name) {\r\n    return services.has(name)\r\n  }\r\n\r\n  /**\r\n   * Returns an instance of a service or `undefined` if service does not exist.\r\n   *\r\n   * @param {string} name - A name of a service.\r\n   * @returns {MessagingService|undefined} If service exists, returns an instance of a service.\r\n   *          If it does not, returns `undefined`.\r\n   */\r\n  static getService (name) {\r\n    return services.get(name)\r\n  }\r\n\r\n  /**\r\n   * Creates an instance of a MessagingService and adds it to the map of instances.\r\n   *\r\n   * @param {string} name - A map of messaging service to create.\r\n   * @param {Destination|Destination[]} destinations - One or several\r\n   *        destination objects to be used with the messaging service.\r\n   * @returns {MessagingService} An instance of a newly created messaging service.\r\n   */\r\n  static createService (name, destinations = []) {\r\n    const service = new MessagingService(name, destinations)\r\n    services.set(name, service)\r\n    return service\r\n  }\r\n\r\n  /**\r\n   * Removes an instance of a MessagingService form the map of instances.\r\n   *\r\n   * @param {string} name - A name of a service to remove.\r\n   * @returns {boolean} True if a service in the map existed and has been removed,\r\n   *          or false if the service does not exist.\r\n   */\r\n  static deleteService (name) {\r\n    return services.delete(name)\r\n  }\r\n\r\n  /**\r\n   * Registers a new destination by adding it to the destinations map and setting a response callback.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  registerDestination (destination) {\r\n    if (this._destinations.has(destination.name)) {\r\n      throw new Error('Destination already exists')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    if (destination.ableToSend) { destination.registerResponseCallback(this.dispatchMessage.bind(this)) }\r\n  }\r\n\r\n  /**\r\n   * Updates a destinations that is already registered.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  updateDestination (destination) {\r\n    if (!this._destinations.has(destination.name)) {\r\n      throw new Error('Cannot update a destination that does not exist')\r\n    }\r\n    // Call `deregister` on the destination in order to let it clean the things up\r\n    this._destinations.get(destination.name).deregister()\r\n    this._destinations.set(destination.name, destination)\r\n    // Register a response callback only if destination supports a SEND mode\r\n    if (destination.ableToSend) { destination.registerResponseCallback(this.dispatchMessage.bind(this)) }\r\n  }\r\n\r\n  /**\r\n   * A function to handle incoming messages.\r\n   *\r\n   * @param {ResponseMessage} message - An incoming response message.\r\n   */\r\n  dispatchMessage (message) {\r\n    if (!Message.isKnownType(message.type)) {\r\n      // Ignore messages that we do not support\r\n      return\r\n    }\r\n    if (!ResponseMessage.isResponse(message)) {\r\n      console.error('A message not following a response format will be ignored:', message)\r\n      return\r\n    }\r\n\r\n    if (!this._messages.has(message.requestID)) {\r\n      /*\r\n      Silently ignore a message with request ID not registered in the map.\r\n      It may be a message that is handled by the other messaging service.\r\n      */\r\n      return\r\n    }\r\n    const requestInfo = this._messages.get(message.requestID)\r\n    window.clearTimeout(requestInfo.timeoutID) // Clear a timeout\r\n    const responseCode = message.responseCode\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // The message returned an error. The message body may contain additional information about an error.\r\n      requestInfo.reject(message)\r\n    } else {\r\n      // Request was processed without errors\r\n      requestInfo.resolve(message)\r\n    }\r\n    this._messages.delete(message.requestID) // Remove request info from the map\r\n  }\r\n\r\n  /**\r\n   * Registers an outgoing request within a request map. Returns a promise that will be fulfilled when\r\n   * a response will be received or rejected when a timeout will expire.\r\n   *\r\n   * @param {RequestMessage} request - An outgoing request.\r\n   * @param {number} timeout - A number of milliseconds we'll wait for response before rejecting a promise.\r\n   * @returns {Promise} - A promise that will be resolved with the message response or rejected with an error info.\r\n   */\r\n  registerRequest (request, timeout = 10000) {\r\n    if (this._messages.has(request.ID)) throw new Error(`Request with ${request.ID} ID is already registered`)\r\n    let storedRequest = new StoredRequest(request) // eslint-disable-line prefer-const\r\n    this._messages.set(request.ID, storedRequest)\r\n    storedRequest.timeoutID = window.setTimeout((requestID) => {\r\n      storedRequest.reject(new Error(`Timeout has been expired for a message with request ID ${request.ID}`))\r\n      this._messages.delete(requestID) // Remove request record from the map\r\n    }, timeout)\r\n    return storedRequest.promise\r\n  }\r\n\r\n  /**\r\n   * Sends a request message to a specific destination.\r\n   *\r\n   * @param {string} destName - A name of a destination where request will be sent to.\r\n   * @param {RequestMessage} request - A request message to be sent.\r\n   * @param {number} timeout - How many milliseconds to wait for a response.\r\n   * @returns {Promise<ResponseMessage> | Promise<Error> | Promise<object>} - A promise either resolved\r\n   *          with response message or rejected with the error info.\r\n   */\r\n  sendRequestTo (destName, request, timeout = 10000) {\r\n    if (!destName) {\r\n      throw new Error('Destination name is not provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    try {\r\n      this._destinations.get(destName).sendRequest(request)\r\n    } catch (err) {\r\n      throw new Error(`Request to ${destName} failed: ${err.message}`)\r\n    }\r\n    // Do not register request before we're sure that the message is sent successfully.\r\n    return this.registerRequest(request, timeout)\r\n  }\r\n}\r\n\r\nMessagingService.errMsgs = {\r\n  NO_NAME: 'MessagingService must be created with a name'\r\n}\r\n","/**\r\n * @module StoredRequest\r\n */\r\n\r\n/** Stores information about request being sent via the messaging service */\r\nexport default class StoredRequest {\r\n  constructor () {\r\n    /**\r\n     * A function to resolve the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.resolve = null\r\n\r\n    /**\r\n     * A function to reject the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.reject = null\r\n\r\n    // A promise that will be resolved or rejected when the response will arrive or the timeout will expire\r\n    this.promise = new Promise(this.executor.bind(this))\r\n  }\r\n\r\n  executor (resolve, reject) {\r\n    this.resolve = resolve\r\n    this.reject = reject\r\n  }\r\n}\r\n","/**\r\n * @module Destination\r\n */\r\n\r\n/** Destination represents a place where messages are sent to and are received from (e.g. a windows) */\r\nexport default class Destination {\r\n  /**\r\n   * Creates an instance of a Destination object. Descendants may take configuration parameters through\r\n   * a second argument that they can define.\r\n   *\r\n   * @param {object} [configuration={}] - A configuration object for a destination.\r\n   * @param {string} configuration.name - A name of a particular destination.\r\n   * @param {string[]} configuration.commModes - A list of communication modes that should be enabled for\r\n   *        a destination. A list of available modes is defined in Destination.commModes.\r\n   *        Defaults to a SEND mode.\r\n   */\r\n  constructor ({ name, commModes = [Destination.commModes.SEND] } = {}) {\r\n    if (!name) {\r\n      throw new Error('Destination name is missing')\r\n    }\r\n\r\n    /**\r\n     * A name of a destination. Used to refer to it within a messaging service.\r\n     *\r\n     * @type {string}\r\n     * @public\r\n     */\r\n    this.name = name\r\n\r\n    /**\r\n     * An array of communication modes that are enabled for a destination.\r\n     *\r\n     * @type {string[]}\r\n     * @public\r\n     */\r\n    this.commModes = commModes\r\n\r\n    /**\r\n     * A function that will be called when a response from destination is received.\r\n     *\r\n     * @type {Function}\r\n     * @private\r\n     */\r\n    this._responseCallback = null\r\n  }\r\n\r\n  /**\r\n   * Checks if a SEND communication mode is enabled for this destination.\r\n   *\r\n   * @returns {boolean} True if destination is in the SEND mode.\r\n   */\r\n  get ableToSend () {\r\n    return this.commModes.includes(Destination.commModes.SEND)\r\n  }\r\n\r\n  /**\r\n   * Checks if a RECEIVE communication mode is enabled for this destination.\r\n   *\r\n   * @returns {boolean} True if destination is in the RECEIVE mode.\r\n   */\r\n  get ableToReceive () {\r\n    return this.commModes.includes(Destination.commModes.RECEIVE)\r\n  }\r\n\r\n  /**\r\n   * This function will be called by the messaging service when a destination is deregistered or deleted.\r\n   * It must do a cleanup necessary for a destination object. Its functionality should be defined within a subclass.\r\n   */\r\n  deregister () {\r\n    throw new Error('Deregister method must be defined in a subclass')\r\n  }\r\n}\r\n\r\n/*\r\nA list of communication modes that a destination can support.\r\n */\r\nDestination.commModes = {\r\n  /*\r\n  If a SEND mode is enabled, this destination can send messages to other destinations of the same type.\r\n   */\r\n  SEND: 'Send',\r\n\r\n  /*\r\n  A RECEIVE mode enables destination to receive messages from other destinations of the same type.\r\n   */\r\n  RECEIVE: 'Receive'\r\n}\r\n","/**\r\n * @module WindowIframeDestination\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport Destination from '@messServ/destinations/destination.js'\r\n\r\n/** WindowIframeDestination represents a content window within an iframe */\r\nexport default class WindowIframeDestination extends Destination {\r\n  /**\r\n   * @param {object} [configuration={}] - An object containing configuration parameters.\r\n   * @param {string} configuration.name - A name of a destination (for addressing a destination in a messaging service).\r\n   * @param {string} configuration.targetURL - A URL of a document within an iframe where messages will be sent.\r\n   * @param {string} configuration.targetIframeID - An ID of an iframe element (without `#`).\r\n   * @param {string[]} configuration.commModes - A list of communication modes that should be enabled for\r\n   *        a destination. A list of available modes is defined in Destination.commModes.\r\n   * @param {Function} configuration.receiverCB - A function that will be called when destination is in the\r\n   *        RECEIVE mode and the incoming request has arrived. This function will receive two parameters:\r\n   *        the message object and the function that will need to be called in order to send a response back.\r\n   */\r\n  constructor ({ name, targetURL, targetIframeID, commModes, receiverCB } = {}) {\r\n    super({ name, commModes })\r\n\r\n    if (!targetURL) {\r\n      throw new Error('Target URL is not provided')\r\n    }\r\n\r\n    if (!targetIframeID) {\r\n      throw new Error('Target iframe ID is not provided')\r\n    }\r\n\r\n    /**\r\n     * A URL of a document within an iframe where messages will be sent.\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetURL = targetURL\r\n\r\n    /**\r\n     * An ID of an iframe element (without `#`).\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetIframeID = targetIframeID\r\n\r\n    if (this.ableToReceive) {\r\n      // Destination is initialized in the receive mode\r\n      if (!receiverCB) {\r\n        throw new Error('A receiver callback must be provided for a destination in the RECEIVE communication mode')\r\n      }\r\n      this._registeredRequestHandler = this._requestHandler.bind(this, receiverCB)\r\n      window.addEventListener('message', this._registeredRequestHandler, false)\r\n    }\r\n\r\n    // The following two props will keep track of request and response handlers registered for this destination.\r\n    this._registeredRequestHandler = null\r\n    this._registeredResponseHandler = null\r\n  }\r\n\r\n  /**\r\n   * Registers a function to call when a response from destination is received.\r\n   *\r\n   * @param {Function} callbackFn - A function to be called when response is received.\r\n   */\r\n  registerResponseCallback (callbackFn) {\r\n    this._registeredResponseHandler = this._responseHandler.bind(this)\r\n    window.addEventListener('message', this._registeredResponseHandler, false)\r\n    this._responseCallback = callbackFn\r\n  }\r\n\r\n  /**\r\n   * A function that will be called to send a request from origin to destination.\r\n   *\r\n   * @param {RequestMessage} requestMessage - A request message object.\r\n   */\r\n  sendRequest (requestMessage) {\r\n    const iframe = document.querySelector(`#${this._targetIframeID}`)\r\n    if (!iframe) {\r\n      throw new Error(`An #${this._targetIframeID} iframe does not exist in the document`)\r\n    }\r\n    const iframeWindow = iframe.contentWindow\r\n\r\n    /*\r\n    If we'll try to send a message to an iframe which content would not been loaded yet,\r\n    `postMessage` will throw an error. It will be impossible, however, to catch this error here because `postMessage`\r\n    executes asynchronously (please see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\r\n    Once the cross-origin iframe content became available, it will throw a DOM security exception\r\n    if we try to access its `location` prop. We can use that to check whether an iframe content is loaded\r\n    before trying to send a message to it.\r\n     */\r\n    let contentNotLoaded = false\r\n    try {\r\n      contentNotLoaded = iframeWindow.location.href === 'about:blank'\r\n    } catch (err) {\r\n      if (err instanceof DOMException) {\r\n        // Do nothing. This error usually means that a cross-origin iframe content has become available.\r\n      } else {\r\n        // Re-throw an error\r\n        throw err\r\n      }\r\n    }\r\n\r\n    if (contentNotLoaded) {\r\n      // If we can access a target iframe location and its URL is blank it means an iframe content is not loaded yet.\r\n      throw new Error(`Target document ${this._targetURL} is not loaded yet`)\r\n    }\r\n    try {\r\n      iframeWindow.postMessage(requestMessage, this._targetURL)\r\n    } catch (err) {\r\n      if (err instanceof DOMException && err.name === 'DataCloneError') {\r\n        /*\r\n        A message body does not confirm the structured clone algorithm and thus cannot be send via `postMessage`.\r\n        See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n        for more details.\r\n        We'll try to convert it to a plain object.\r\n         */\r\n        console.warn('Request that does not confirm to the structured clone algorithm cannot be sent, ' +\r\n          'will try to convert it to a plain object and send again')\r\n        requestMessage.body = WindowIframeDestination._toPostable(requestMessage.body)\r\n        // Try to resend a message\r\n        iframeWindow.postMessage(requestMessage, this._targetURL)\r\n      } else {\r\n        // Some other error occurred, rethrow it\r\n        throw err\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A function that is used to send a response from destination to origin.\r\n   *\r\n   * @param {ResponseMessage} responseMessage - A response message object.\r\n   */\r\n  sendResponse (responseMessage) {\r\n    try {\r\n      window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n    } catch (err) {\r\n      if (err instanceof DOMException && err.name === 'DataCloneError') {\r\n        /*\r\n        A message body does not confirm the structured clone algorithm and thus cannot be send via `postMessage`.\r\n        See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n        for more details.\r\n        We'll try to convert it to a plain object.\r\n         */\r\n        console.warn('Response that does not confirm to the structured clone algorithm cannot be sent, ' +\r\n                     'will try to convert it to a plain object and send again')\r\n        responseMessage.body = WindowIframeDestination._toPostable(responseMessage.body)\r\n        // Try to resend a message\r\n        window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n      } else {\r\n        // Some other error occurred, rethrow it\r\n        throw err\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when request arrives to its destination.\r\n   *\r\n   * @param {Function} callbackFn - A client's callback function that will be called and\r\n   *                                passed a request (a `RequestMessage` object).\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _requestHandler (callbackFn, event) {\r\n    // Check if an event contains a valid Alpheios message object.\r\n    if (!WindowIframeDestination._isSupportedEvent(event)) { return }\r\n\r\n    // `data` prop of an event contains a request message object\r\n    let request = event.data // eslint-disable-line prefer-const\r\n    request.header.origin = event.origin\r\n    callbackFn(request, this.sendResponse.bind(this))\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when response arrives from destination to origin.\r\n   *\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _responseHandler (event) {\r\n    // Check if an event contains a valid Alpheios message object.\r\n    if (!WindowIframeDestination._isSupportedEvent(event)) { return }\r\n\r\n    // `data` prop of an event contains a response message object\r\n    const responseMessage = event.data\r\n    if (this._responseCallback) {\r\n      this._responseCallback(responseMessage)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks whether an event contains a well-formed Alpheios message object.\r\n   *\r\n   * @param {Event} event - An event that may contain a message object in a `data` field.\r\n   * @returns {boolean} - True if an event contains a well-formed Alpheios message object, false otherwise.\r\n   * @private\r\n   */\r\n  static _isSupportedEvent (event) {\r\n    return Boolean(event && event.data && event.data.type && Message.isKnownType(event.data.type))\r\n  }\r\n\r\n  /**\r\n   * This function will be called by the messaging service when destination is deregistered or deleted.\r\n   * It must do a cleanup for a destination object.\r\n   */\r\n  deregister () {\r\n    // Remove event listeners for registered request and response handlers\r\n    if (this._registeredResponseHandler) {\r\n      window.removeEventListener('message', this._registeredResponseHandler, false)\r\n      this._registeredResponseHandler = null\r\n    }\r\n    if (!this._registeredRequestHandler) {\r\n      window.removeEventListener('message', this._registeredRequestHandler, false)\r\n      this._registeredRequestHandler = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an object to the one that is conforms the structured clone algorithm.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n   * for more details.\r\n   *\r\n   * @param {object} message - An object to convert.\r\n   * @returns {object} - An object that conforms to the structured clone algorithm.\r\n   * @private\r\n   */\r\n  static _toPostable (message) {\r\n    let postable\r\n    if (message instanceof Error) {\r\n      /*\r\n      Due to the bug in FF, Errors cannot be sent via postMessage yet.\r\n      Please see https://bugzilla.mozilla.org/show_bug.cgi?id=1556604 for more details.\r\n      This code can be removed once the bug is fixed.\r\n       */\r\n      postable = {\r\n        name: message.name,\r\n        message: message.message\r\n      }\r\n    } else {\r\n      postable = JSON.parse(JSON.stringify(message))\r\n    }\r\n    return postable\r\n  }\r\n}\r\n","/**\r\n * @module Message\r\n */\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\n/** A base class for all types of messages */\r\nexport default class Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    /**\r\n     * A message's role (@see {@link Message.roles}). Will be defined in descendants.\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.role = undefined\r\n\r\n    /**\r\n     * A type of the message. Used to distinguish one kind of message from the other (@see {@link Message.types}).\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.type = Message.types.GENERIC\r\n\r\n    /**\r\n     * A unique identifier of the message.\r\n     *\r\n     * @type {string}\r\n     */\r\n    this.ID = uuidv4()\r\n\r\n    /**\r\n     * An object with no methods representing a message body.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.body = body\r\n  }\r\n\r\n  static isKnownType (typeValue) {\r\n    return Object.values(Message.types).includes(typeValue)\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a message is request or response.\r\n */\r\nMessage.roles = {\r\n  REQUEST: 'Request',\r\n  RESPONSE: 'Response'\r\n}\r\n\r\n/**\r\n * Specifies a message type: what kind of message it is and what purpose it serves.\r\n * Message types are used to distinguish different types of messages from each other\r\n * and to distinguish Alpheios from non-Alpheios messages. All Alpheios messages\r\n * must start from an `ALPHEIOS_` prefix.\r\n */\r\nMessage.types = {\r\n  GENERIC: 'ALPHEIOS_MESSAGE' // A generic message of general purpose\r\n}\r\n","/**\r\n * @module RequestMessage\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\n\r\n/** A request message */\r\nexport default class RequestMessage extends Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    super(body)\r\n    this.role = Message.roles.REQUEST\r\n\r\n    /**\r\n     * A message header. Will contain routing information usually.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.header = {}\r\n  }\r\n}\r\n","/**\r\n * @module ResponseMessage\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport RequestMessage from '@messServ/messages/request-message.js'\r\n\r\n/** A response message that is sent as an answer to the request message. */\r\nexport default class ResponseMessage extends Message {\r\n  /**\r\n   * @param {RequestMessage} request - A request that initiated this response. Used to copy routing information mostly.\r\n   * @param {object} [body={}] - A body of the response, a plain JS object with no methods.\r\n   * @param {string} responseCode - A code to indicate results of the request handling: Success, Failure, etc.\r\n   * @param {object} options - Additional non-obligatory parameters:\r\n   * @param {number} options.errorCode - An error code indicating why request has failed.\r\n   */\r\n  constructor (request, body = {}, responseCode = ResponseMessage.responseCodes.UNDEFINED, { errorCode } = {}) {\r\n    super(body)\r\n    if (!request) throw new Error('Request is not provided')\r\n    if (!request.ID) throw new Error('Request has no ID')\r\n    this.role = Message.roles.RESPONSE\r\n    this.requestHeader = request.header || {}\r\n    this.requestID = request.ID // ID of the request to match request and response\r\n    this.responseCode = responseCode\r\n\r\n    /**\r\n     * If request failed this prop will contain an error code indicating the reason of the failure.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.errorCode = 0\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // Request has failed. An error code must be provided.\r\n      if (!errorCode) {\r\n        throw new Error('An error code must be provided for failed requests')\r\n      }\r\n      this.errorCode = errorCode\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A builder for a response message with a SUCCESS response code.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {object} [body={}] - A body of response message.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Success (request, body = {}) {\r\n    return new this(request, body, ResponseMessage.responseCodes.SUCCESS)\r\n  }\r\n\r\n  /**\r\n   * A builder for a message with an ERROR response code. Error information will be sent within the message body.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {Error} error - An error object containing error information.\r\n   * @param {number} errorCode - An error code indicating why a request failed.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Error (request, error, errorCode) {\r\n    return new this(request, error, ResponseMessage.responseCodes.ERROR, { errorCode })\r\n  }\r\n\r\n  /**\r\n   * Checks if this message is a response (i.e. if it follows a response message format and conventions).\r\n   *\r\n   * @param {RequestMessage | ResponseMessage} message - A request or response message to be tested.\r\n   * @returns {boolean} - True if the message is a response, false otherwise.\r\n   */\r\n  static isResponse (message) {\r\n    return message.role &&\r\n      message.role === Message.roles.RESPONSE &&\r\n      message.requestHeader &&\r\n      message.requestID\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a request was processed successfully or not.\r\n */\r\nResponseMessage.responseCodes = {\r\n  // Request was processed successfully.\r\n  // In this case a message body may contain a response data object or be empty.\r\n  SUCCESS: 'Success',\r\n\r\n  // There is no information about what was the outcome of a request.\r\n  UNDEFINED: 'Undefined',\r\n\r\n  // Request failed. A message will contain information about an error.\r\n  ERROR: 'Error'\r\n}\r\n\r\n/**\r\n * If request failed, the error code will be used to indicate the reason of a failure.\r\n */\r\nResponseMessage.errorCodes = {\r\n  // A remote service has not been initialized yet\r\n  SERVICE_UNINITIALIZED: 1,\r\n  // An error occurred during initialization of a remote service\r\n  INITIALIZATION_ERROR: 2,\r\n  // Request of unknown type is received by a remote service\r\n  UNKNOWN_REQUEST: 3,\r\n  // An unspecified error has occurred inside a remote service\r\n  INTERNAL_ERROR: 4\r\n}\r\n","/**\r\n * @module CedictStorage\r\n */\r\nimport Storage from '@lexisCs/cedict-service/storage.js'\r\nimport IndexedDbStore from '@lexisCs/cedict-service/indexed-db-store.js'\r\n\r\n/** A representation of a permanent data storage for CEDICT dictionary */\r\nexport default class CedictPermanentStorage extends Storage {\r\n  constructor (configuration) {\r\n    super(configuration)\r\n    this._configuration = configuration\r\n    this._db = null\r\n    // A map to keep store objects\r\n\r\n    /**\r\n     * A map to keep store objects. CedictPermanentStorage has two: 'meta' and 'dictionary'.\r\n     * The key is the store name and the value is a store object.\r\n     *\r\n     * @type {Map<string, IndexedDbStore>}\r\n     */\r\n    this._stores = new Map()\r\n    // A key that provides access to the metadata object in the `meta` store.\r\n    this.metaKey = 1\r\n    Object.values(this._configuration.stores)\r\n      .forEach(storeConfig => { this._stores.set(storeConfig.name, new IndexedDbStore(storeConfig)) })\r\n  }\r\n\r\n  /**\r\n   * Called internally by a super class to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(CedictPermanentStorage.errMsgs.NO_STORAGE_NAME)\r\n    if (!configuration.version) throw new Error(CedictPermanentStorage.errMsgs.NO_STORAGE_VERSION)\r\n    if (!configuration.stores) throw new Error(CedictPermanentStorage.errMsgs.NO_STORES)\r\n  }\r\n\r\n  /**\r\n   * Asserts that a database connection is opened.\r\n   *\r\n   * @private\r\n   */\r\n  _assertConnection () {\r\n    if (!this._db) throw new Error(CedictPermanentStorage.errMsgs.CLOSED_CONNECTION)\r\n  }\r\n\r\n  /**\r\n   * Checks if a store with a given name exists.\r\n   *\r\n   * @param {string} storeName - The name of the store.\r\n   * @returns {boolean} true if store exists or false otherwise.\r\n   */\r\n  hasStore (storeName) {\r\n    return this._stores.has(storeName)\r\n  }\r\n\r\n  /**\r\n   * Returns a store object. It will throw an error if store does not exist\r\n   * of if a connection to the database is closed.\r\n   *\r\n   * @param {string} storeName - A name of a store to get.\r\n   * @returns {IndexedDbStore} An instance of a store object.\r\n   */\r\n  getStore (storeName) {\r\n    if (!this._stores.has(storeName)) throw new Error(CedictPermanentStorage.errMsgs.MISSING_STORE)\r\n    this._assertConnection()\r\n    return this._stores.get(storeName)\r\n  }\r\n\r\n  /**\r\n   * Returns information to verify storage integrity. Integrity data is specific for each particular\r\n   * storage type.\r\n   *\r\n   * @returns {Promise<{metadata: {object}, recordsInMeta: {number}, recordsInDictionary: {number}}>|Promise<Error>}\r\n   *          Returns a promise that is resolved an object with storage integrity data or is rejected\r\n   *          if storage integrity is broken. Integrity data object contains the following information:\r\n   *          a CEDICT metadata object that is contained in the `meta` store, number of records\r\n   *          in `meta` and `dictionary` _stores.\r\n   */\r\n  getIntegrityData () {\r\n    this._assertConnection()\r\n    let integrityRequests\r\n    try {\r\n      integrityRequests = [this._stores.get('meta'), this._stores.get('dictionary')].map(store => store.count()) // eslint-disable-line prefer-const\r\n      integrityRequests.push(this._stores.get('meta').get(this.metaKey))\r\n    } catch (error) {\r\n      return Promise.reject(error)\r\n    }\r\n    return Promise.all(integrityRequests).then(([recordsInMeta, recordsInDictionary, metadata]) => {\r\n      if (!metadata || metadata.length === 0) throw new Error(CedictPermanentStorage.errMsgs.NO_META)\r\n      return { recordsInMeta, recordsInDictionary, metadata: metadata[0] }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * This is a primary method of establishing connection to the storage.\r\n   * If storage and _stores it contains do not exist, connect() will create them.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          established successfully or is rejected if connection fails.\r\n   */\r\n  connect () {\r\n    return new Promise((resolve, reject) => {\r\n      let openRequest\r\n      try {\r\n        // If database does not exist, openRequest will create it and will trigger an onupgradeneeded followed by onsuccess\r\n        openRequest = indexedDB.open(this._configuration.name, this._configuration.version) // eslint-disable-line prefer-const\r\n      } catch (error) {\r\n        reject(error)\r\n      }\r\n      openRequest.onupgradeneeded = this._create.bind(this, openRequest)\r\n      openRequest.onblocked = () => reject(new Error(CedictPermanentStorage.errMsgs.BLOCKED_ON_OPEN))\r\n\r\n      openRequest.onsuccess = () => {\r\n        this._db = openRequest.result\r\n        this._db.onversionchange = this._versionchangeHandler.bind(this, reject)\r\n        this._stores.forEach(store => store.associateWith(this._db))\r\n        resolve()\r\n      }\r\n\r\n      openRequest.onerror = (error) => { reject(error) }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Disconnects from the storage.\r\n   *\r\n   * @returns {Promise<undefined>} Always returns a resolved promise.\r\n   */\r\n  disconnect () {\r\n    if (this._db) {\r\n      this._stores.forEach(store => store.dissociate())\r\n      this._db.close()\r\n      this._db = null\r\n    }\r\n    return Promise.resolve()\r\n  }\r\n\r\n  /**\r\n   * Clears all stores in a storage.\r\n   *\r\n   * @returns {Promise<any>|Promise<Error>} A promise that is resolved when all stores are cleared\r\n   *          or is rejected if clearing at least one of the stores failed.\r\n   */\r\n  clear () {\r\n    this._assertConnection()\r\n    return Promise.all(Array.from(this._stores.values()).map(store => store.clear()))\r\n  }\r\n\r\n  /**\r\n   * Called to create a storage when one does not exist or is of incorrect version.\r\n   * This method cannot be called directly, only as a result of an onupgradeneeded event\r\n   * triggered by the open DB request. Use 'connect()` to establish connection ot a database,\r\n   * and it will invoke `_create()` if necessary.\r\n   *\r\n   * @param {IDBOpenDBRequest} openRequest - An open request that caused an onupgradeneeded event.\r\n   * @param {Function} reject - A reject function for promise declared in `connect()`.\r\n   * @returns {Promise} A promise that is resolved if storage is created successfully or\r\n   *                    is rejected otherwise.\r\n   */\r\n  _create (openRequest, reject) {\r\n    this._db = openRequest.result\r\n    const storeCreateRequests = Array.from(this._stores.values()).map(store => store.associateWith(this._db).create())\r\n    return Promise.all(storeCreateRequests)\r\n  }\r\n\r\n  /**\r\n   * Destroys a storage and all the _stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all _stores were destroyed successfully or is rejected if operations fails.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertConnection()\r\n      this.disconnect().then(() => {\r\n        const deleteRequest = indexedDB.deleteDatabase(this._configuration.name)\r\n        deleteRequest.onsuccess = () => { resolve() }\r\n        deleteRequest.onerror = () => { reject(new Error(CedictPermanentStorage.errMsgs.DESTRUCTION_ERROR)) }\r\n      })\r\n    })\r\n  }\r\n\r\n  async _versionchangeHandler (reject) {\r\n    await this.disconnect()\r\n    console.error(CedictPermanentStorage.errMsgs.VERSION_CHANGE)\r\n    reject(new Error(CedictPermanentStorage.errMsgs.VERSION_CHANGE))\r\n  }\r\n}\r\n\r\nCedictPermanentStorage.errMsgs = {\r\n  NO_STORAGE_NAME: 'Storage name is missing from a configuration',\r\n  NO_STORAGE_VERSION: 'Storage version is missing from a configuration',\r\n  NO_STORES: 'No stores are defined in a configuration',\r\n  NO_META: 'Metadata store has no records',\r\n  DESTRUCTION_ERROR: 'Unable to destroy a storage',\r\n  MISSING_STORE: 'The store requested does not exist',\r\n  CLOSED_CONNECTION: 'Connection to the store is closed',\r\n  BLOCKED_ON_OPEN: 'Request to open a database has been blocked',\r\n  VERSION_CHANGE: 'A database change has occurred. You should refresh this browser window or close it down.'\r\n}\r\n","/**\r\n * @module CedictData\r\n */\r\nimport { CedictCharacterForms } from '@lexisCs/cedict-service/constants.js'\r\nimport CedictPermanentStorage from '@lexisCs/cedict-service/cedict-permanent-storage.js'\r\n\r\n/** A class to serve data from CEDICT */\r\nexport default class Cedict {\r\n  /**\r\n   * @param {object} configuration - An object that describes a configuration of a CEDICT data object.\r\n   */\r\n  constructor (configuration) {\r\n    Cedict.checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n\r\n    /**\r\n     * Whether the object is ready to serve data or not.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    this.isReady = false\r\n\r\n    this._storage = new CedictPermanentStorage(this._configuration.storage)\r\n\r\n    /**\r\n     * If CEDICT be stored in memory this object will hold all its data.\r\n     *\r\n     * @type {{entries: object[]|Map, meta: {}}}\r\n     */\r\n    this.cedict = {\r\n\r\n      // A dictionary's metadata\r\n      meta: {},\r\n\r\n      metaKey: 1,\r\n\r\n      /**\r\n       * If data is stored in memory `entries` will keep either\r\n       * an array of dictionary records (if no in memory indexes will be employed) or\r\n       * a map of dictionary records (if in memory indexes will be used).\r\n       * If dictionary data will be stored in permanents storage only `entries` will be null\r\n       */\r\n      dictionary: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `traditionalHeadwordsIdx`\r\n       * will hold a map: Map<traditionalHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      traditionalHeadwordsIdx: null,\r\n\r\n      /**\r\n       * If in memory indexes be used, `simplifiedHeadwordsIdx`\r\n       * will hold a map: Map<simplifiedHeadword, Array[entryIndex]>. Otherwise it will be null.\r\n       */\r\n      simplifiedHeadwordsIdx: null\r\n    }\r\n\r\n    /*\r\n    If characterForm is not specified in the request we will search for records with the\r\n    preferred character form specified below first. If any results for that character form will be found,\r\n    only those ones will be returned to the client. If no results for the preferred character form\r\n    are in the dictionary then we will search for records with other character forms.\r\n    NOTE: This constant is used inside a stub in `fixtures/src/cedict/cedict-fixture.js`.\r\n    If you will change this constant please update it in the stab as well.\r\n     */\r\n    this.preferredCharacterForm = CedictCharacterForms.TRADITIONAL\r\n\r\n    /*\r\n    This is a character form we will fallback into if matches for the preferred one are not found.\r\n    NOTE: This constant is used inside a stub in `fixtures/src/cedict/cedict-fixture.js`.\r\n    If you will change this constant please update it in the stab as well.\r\n     */\r\n    this.fallbackCharacterForm = CedictCharacterForms.SIMPLIFIED\r\n  }\r\n\r\n  /**\r\n   * Checks if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   */\r\n  static checkConfiguration (configuration) {\r\n    if (!configuration.storage) throw new Error(Cedict.errMsgs.CONF_NO_STORAGE)\r\n    if (!configuration.storage.stores) throw new Error(Cedict.errMsgs.CONF_NO_STORES)\r\n    if (!configuration.storage.stores.dictionary) throw new Error(Cedict.errMsgs.CONF_NO_DICT)\r\n    if (!configuration.storage.stores.dictionary.primaryIndex) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PRIMARY_IDX)\r\n    if (!configuration.storage.stores.dictionary.primaryIndex.hasOwnProperty('keyPath')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PRIMARY_IDX_KEY_PATH)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage.hasOwnProperty('enabled')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE_ENABLED)\r\n    if (!configuration.storage.stores.dictionary.volatileStorage.hasOwnProperty('indexed')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_VOLATILE_INDEXED)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage.hasOwnProperty('enabled')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM_ENABLED)\r\n    if (!configuration.storage.stores.dictionary.permanentStorage.hasOwnProperty('indexed')) throw new Error(Cedict.errMsgs.CONF_NO_DICT_PERM_INDEXED)\r\n    if (!configuration.data) throw new Error(Cedict.errMsgs.CONF_NO_DATA)\r\n    if (!configuration.data.version) throw new Error(Cedict.errMsgs.CONF_NO_DATA_VER)\r\n    if (!configuration.data.revision) throw new Error(Cedict.errMsgs.CONF_NO_DATA_REV)\r\n    if (!configuration.data.recordsCount) throw new Error(Cedict.errMsgs.CONF_NO_DATA_REC_COUNT)\r\n    if (!configuration.data.URI) throw new Error(Cedict.errMsgs.CONF_NO_DATA_URI)\r\n    if (!configuration.data.chunks || configuration.data.chunks.length === 0) throw new Error(Cedict.errMsgs.CONF_NO_DATA_CHUNKS)\r\n  }\r\n\r\n  /**\r\n   * Initializes a data object.\r\n   *\r\n   * @returns {Promise<undefined> | Promise<Error>} Returns a promise that is resolved with undefined\r\n   *          if initialization succeeded or is rejected with an error object if initialization failed.\r\n   */\r\n  async init () {\r\n    let indexedDbSupported = true\r\n    try {\r\n      // Try to establish connection to an IndexedDB\r\n      await this._storage.connect()\r\n    } catch (error) {\r\n      if (error.name === Cedict.errNames.SECURITY_ERR) {\r\n        /*\r\n        Security error indicates that IndexedDB is not available in the current environment.\r\n        This can be a case of a cross origin use of IndexedDB in Safari.\r\n         */\r\n        indexedDbSupported = false\r\n        console.warn('LexisCS will disable IndexedDB because it is not supported in the current environment')\r\n      } else {\r\n        throw error\r\n      }\r\n    }\r\n    return indexedDbSupported ? this._initWithIndexedDb() : this._initWithoutIndexedDb()\r\n  }\r\n\r\n  /**\r\n   * Checks if there is a valid CEDICT data stored in an IndexedDB\r\n   *\r\n   * @returns {Promise<boolean>} - A promise that is resolved with `true` if there is valid data\r\n   *          or the promise resolved with `false` if data is incomplete, broken, or missing.\r\n   */\r\n  async hasDataLoaded () {\r\n    let result\r\n    try {\r\n      await this._storage.connect()\r\n      const integrityData = await this._storage.getIntegrityData()\r\n      result = this.isStorageIntact(integrityData)\r\n    } catch (error) {\r\n      result = false\r\n    } finally {\r\n      await this._storage.disconnect()\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * This initialization method is called when IndexedDB is available, i.e. in majority of cases.\r\n   *\r\n   * @returns {Promise<undefined> | Promise<Error>} Returns a promise that is resolved with undefined\r\n   *          if initialization succeeded or is rejected with an error object if initialization failed.\r\n   * @private\r\n   */\r\n  _initWithIndexedDb () {\r\n    /*\r\n    This method is called when a caller has already establish a connection to the store successfully\r\n    `storage.connect()` will create a database if it does not exist yet.\r\n     */\r\n    return new Promise((resolve, reject) => {\r\n      return this._storage.getIntegrityData()\r\n        .then((integrityData) => {\r\n          /*\r\n          Integrity data has been returned successfully which means database structure is OK.\r\n          Let's check if there is a new version of data available on a server.\r\n           */\r\n          if (!this.isStorageIntact(integrityData)) {\r\n            throw new Error('Storage is outdated')\r\n          }\r\n          // Data in storage is fresh so we can read it into memory structures if we have that option enabled\r\n          if (this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n            return this._storage.getStore('dictionary').getAllEntries()\r\n              .then((entries) => this._populateVolatileStorage(integrityData.metadata, entries))\r\n              .catch((error) => reject(error))\r\n          }\r\n        })\r\n        .catch(() => {\r\n          // Data in permanent storage needs to be updated\r\n          return this.removePermanentData()\r\n            // `connect()` will create storage and stores\r\n            .then(() => this._storage.connect())\r\n            .then(() => this._downloadData())\r\n            .then(({ meta, dictionary }) => {\r\n              if (this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n                this._populateVolatileStorage(meta, dictionary)\r\n              }\r\n              // Even if permanent storage is disabled we will still populate in order to avoid downloading data again\r\n              return this._populatePermanentStorage(meta, dictionary)\r\n                .then(() => Promise.resolve())\r\n                .catch((error) => {\r\n                  console.error('Unable to store CEDICT data to IndexedDB.', error)\r\n                  // Cannot write CEDICT data to IndexedDB. Will fall back to an in-memory location\r\n                  if (!this._configuration.storage.stores.dictionary.volatileStorage.enabled) {\r\n                    console.warn('Switched to in-memory placement of CEDICT data')\r\n                    this._configuration.storage.stores.dictionary.volatileStorage.enabled = true\r\n                    this._populateVolatileStorage(meta, dictionary)\r\n                  }\r\n                  return Promise.resolve()\r\n                })\r\n            })\r\n        })\r\n        .then(() => {\r\n          this.isReady = true\r\n          resolve()\r\n        })\r\n        .catch((error) => { reject(error) })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * This initialization method is for situations when IndexedDB is not available.\r\n   * This can happen in, for example, Safari, which does not allow to access\r\n   * cross domain IndexedDBs from within an iframe.\r\n   * In that case we will rely on in-memory placement only.\r\n   *\r\n   * @returns {Promise<void>|Promise<Error|*>} Promise that is resolved with undefined if initialization\r\n   *          succeeded or is rejected with an error object if initialization fails.\r\n   * @private\r\n   */\r\n  async _initWithoutIndexedDb () {\r\n    const { meta, dictionary } = await this._downloadData()\r\n    /*\r\n    This init method is called when IndexedDB is not available.\r\n    Because of this, we will force disable an IndexedDB permanent storage in a configuration.\r\n    We will also force enable an indexed version of a volatile storage,\r\n    that will be the only storage we will use in that case.\r\n     */\r\n    this._configuration.storage.stores.dictionary.permanentStorage.enabled = false\r\n    this._configuration.storage.stores.dictionary.volatileStorage.enabled = true\r\n    this._configuration.storage.stores.dictionary.volatileStorage.indexed = true\r\n    await this._populateVolatileStorage(meta, dictionary)\r\n    this.isReady = true\r\n  }\r\n\r\n  /**\r\n   * Deletes all permanent data associated with CEDICT data object.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if data is cleared successfully\r\n   *          or rejected if operation failed.\r\n   */\r\n  removePermanentData () {\r\n    return this._storage.destroy()\r\n  }\r\n\r\n  /**\r\n   * Checks if the character form supplied is the one we have records upon.\r\n   *\r\n   * @param {string} characterForm - A string identifying a character form\r\n   *        as defined in CedictCharacterForms.\r\n   * @returns {boolean} True if there is information on this form, false otherwise.\r\n   */\r\n  static isSupportedCharacterForm (characterForm) {\r\n    return Array.from(Object.values(CedictCharacterForms)).includes(characterForm)\r\n  }\r\n\r\n  /**\r\n   * Verifies whether data in a storage is OK by checking its integrity information.\r\n   *\r\n   * @param {object} integrityData - A JSON-like object containing a storage integrity data.\r\n   * @returns {boolean} True if storage is intact and false otherwise.\r\n   */\r\n  isStorageIntact (integrityData) {\r\n    return (\r\n      integrityData.recordsInMeta === 1 &&\r\n      integrityData.recordsInDictionary === this._configuration.data.recordsCount &&\r\n      integrityData.metadata.version === this._configuration.data.version &&\r\n      integrityData.metadata.revision === this._configuration.data.revision\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records from CEDICT dictionary for one or several Chinese words.\r\n   * NOTE: The business logic from this method is used inside a `lexisCedictRequest()` stub\r\n   * in `fixtures/src/cedict/cedict-fixture.js`. If the business logic will be updated\r\n   * please update the stub to match the change.\r\n   *\r\n   * @param {string|[string]} words - A single Chinese word or an array of Chinese words.\r\n   * @param {string|undefined} [characterForm=undefined] - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {object} - Returns an object whose keys are character forms and values are\r\n   *          objects with requested words as keys and values are arrays of CEDICT records\r\n   *          that has those words.\r\n   */\r\n  getWords (words, characterForm) {\r\n    // CedictData object is not prepared to serve this request\r\n    if (!this.isReady) return Promise.reject(new Error(Cedict.errMsgs.NOT_READY))\r\n\r\n    let characterFormIsNotKnown = true\r\n    // If character form is not specified it will try to find a best suitable one\r\n    if (typeof characterForm !== 'undefined') {\r\n      // Some value is provided for a characterForm\r\n      if (!Cedict.isSupportedCharacterForm(characterForm)) return Promise.reject(new Error(`${Cedict.errMsgs.BAD_CHAR_FORM} \"${characterForm}\"`))\r\n      characterFormIsNotKnown = false\r\n    }\r\n\r\n    // Nothing to do\r\n    if (!words) return Promise.resolve({})\r\n\r\n    // Decide whether word entries will be retrieved from memory or form a permanent storage\r\n    const getWordsFunc = this._configuration.storage.stores.dictionary.volatileStorage.enabled\r\n      ? this._getWordsFromVolatileStorage.bind(this)\r\n      : this._getWordsFromPermanentStorage.bind(this)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (characterFormIsNotKnown) {\r\n        // Search using preferred character form first\r\n        getWordsFunc(words, this.preferredCharacterForm)\r\n          .then((entries) => {\r\n            if (Cedict._getResultRecordsCount(entries) > 0) {\r\n              // There are matches with the preferred character form, we need to search no longer\r\n              resolve({ [this.preferredCharacterForm]: entries })\r\n            } else {\r\n              // Search using fallback character form\r\n              return getWordsFunc(words, this.fallbackCharacterForm)\r\n            }\r\n          })\r\n          .then((entries) => {\r\n            // Results for the fallback character form\r\n            const result = (Cedict._getResultRecordsCount(entries) > 0) ? { [this.fallbackCharacterForm]: entries } : {}\r\n            resolve(result)\r\n          })\r\n          .catch((error) => reject(error))\r\n      } else {\r\n        // Return records for a specified character set\r\n        getWordsFunc(words, characterForm)\r\n          .then((entries) => {\r\n            const result = (Cedict._getResultRecordsCount(entries) > 0) ? { [characterForm]: entries } : {}\r\n            resolve(result)\r\n          })\r\n          .catch((error) => reject(error))\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records for given words from an in-memory storage.\r\n   * It returns a promise to make it signature compatible with other word retrieval functions.\r\n   *\r\n   * @param {[string]} words - An array of Chinese words.\r\n   * @param {string} characterForm - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {Promise<object> | Promise<Error>} - Returns a promise that is resolved with an object\r\n   *          whose keys are the words requested and values are arrays of CEDICT records that has those words.\r\n   *          If an error occurred, the promise is rejected with an error.\r\n   */\r\n  _getWordsFromVolatileStorage (words, characterForm) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        // If a single word value is provided, convert it into an array\r\n        if (!Array.isArray(words)) { words = [words] }\r\n        // Create an object with props for the words\r\n        let result = words.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n        // Retrieve from memory\r\n        if (this._configuration.storage.stores.dictionary.volatileStorage.indexed) {\r\n          // Use in memory indexes to find values\r\n          words.forEach(word => {\r\n            const idx = (characterForm === CedictCharacterForms.SIMPLIFIED)\r\n              ? this.cedict.simplifiedHeadwordsIdx.get(word)\r\n              : this.cedict.traditionalHeadwordsIdx.get(word)\r\n            result[word] = idx ? idx.map(idx => this.cedict.dictionary.get(idx)) : []\r\n          })\r\n        } else {\r\n          // Indexes are not available, iterate over an array of values\r\n          this.cedict.dictionary.forEach(entry => {\r\n            const hw = (characterForm === CedictCharacterForms.SIMPLIFIED) ? entry.simplified.headword : entry.traditional.headword\r\n            words.forEach(word => {\r\n              if (hw === word) {\r\n                result[word].push(entry)\r\n              }\r\n            })\r\n          })\r\n        }\r\n        resolve(result)\r\n      } catch (error) {\r\n        reject(error)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns one or several records for given words from a permanent storage.\r\n   *\r\n   * @param {[string]} words - An array of Chinese words.\r\n   * @param {string} characterForm - A string constant that specifies\r\n   *        a character form in words (simplified or traditional).\r\n   * @returns {Promise<object> | Promise<Error>} - Returns a promise that is resolved with an object\r\n   *          whose keys are the words requested and values are arrays of CEDICT records that has those words.\r\n   *          If an error occurred, the promise is rejected with an error.\r\n   */\r\n  _getWordsFromPermanentStorage (words, characterForm) {\r\n    const index = (characterForm === CedictCharacterForms.SIMPLIFIED) ? 'simplifiedHwIdx' : 'traditionalHwIdx'\r\n    return this._storage.getStore('dictionary').getEntries(words, { index })\r\n  }\r\n\r\n  /**\r\n   * Loads fresh CEDICT data from a remote server.\r\n   * NOTE: fixtures/src/cedict/cedict-fixture.js implements a stub for this method. If signature and/or business\r\n   * logic of this method is changed, please update the stub accordingly.\r\n   *\r\n   * @returns {Promise<{meta: object, dictionary: object[]}> | Promise<Error>} - Returns a promise that will be resolved with undefined\r\n   *          if data was loaded successfully or that will be rejected with an error with data loading will fail.\r\n   */\r\n  _downloadData () {\r\n    const requests = this._configuration.data.chunks.map(chunk => this._loadJson(`${this._configuration.data.URI}/${chunk}`))\r\n    return Promise.all(requests).then(chunks => {\r\n      let meta = chunks[0].metadata // eslint-disable-line prefer-const\r\n      // CEDICT metadata will be stored within a `cedict` property of an app-wide metadata object\r\n      meta.cedict = chunks[0].cedictMeta\r\n      delete meta.chunkNumber\r\n      return { meta, dictionary: chunks.map(piece => piece.entries).flat() }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Stores CEDICT dictionary data into an in-memory storage.\r\n   *\r\n   * @param {object} meta - A metadata object.\r\n   * @param {object[]} dictionary - An array of dictionary records.\r\n   */\r\n  _populateVolatileStorage (meta, dictionary) {\r\n    this.cedict.meta = meta\r\n    if (this._configuration.storage.stores.dictionary.volatileStorage.indexed) {\r\n      // Dictionary entries will be placed into a map using a primary key.\r\n      this.cedict.dictionary = new Map()\r\n      dictionary.forEach(entry => this.cedict.dictionary.set(entry[this._configuration.storage.stores.dictionary.primaryIndex.keyPath], entry))\r\n      // Additional maps will be created for each index.\r\n      this._indexVolatileStorage()\r\n    } else {\r\n      // No indexes will be created and dictionary entries will be placed into an array\r\n      this.cedict.dictionary = dictionary\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates indexes for an in-memory storage.\r\n   */\r\n\r\n  _indexVolatileStorage () {\r\n    this.cedict.traditionalHeadwordsIdx = new Map()\r\n    this.cedict.simplifiedHeadwordsIdx = new Map()\r\n    this.cedict.dictionary.forEach(entry => {\r\n      this.cedict.traditionalHeadwordsIdx.has(entry.traditional.headword)\r\n        ? this.cedict.traditionalHeadwordsIdx.get(entry.traditional.headword).push(entry.index)\r\n        : this.cedict.traditionalHeadwordsIdx.set(entry.traditional.headword, [entry.index])\r\n      this.cedict.simplifiedHeadwordsIdx.has(entry.simplified.headword)\r\n        ? this.cedict.simplifiedHeadwordsIdx.get(entry.simplified.headword).push(entry.index)\r\n        : this.cedict.simplifiedHeadwordsIdx.set(entry.simplified.headword, [entry.index])\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Records CEDICT data to the permanent storage.\r\n   *\r\n   * @param {object} meta - A metadata object.\r\n   * @param {object[]} dictionary - An array of dictionary records.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if data has been written successfully\r\n   *          or is reject if write operations failed.\r\n   */\r\n  async _populatePermanentStorage (meta, dictionary) {\r\n    /*\r\n    `update` is used instead of `insert` here because `meta` store has only one record\r\n    and it's index must be as defined in `this.cedict.metaKey`.\r\n    Only the use of `update` allow to specify an index for the record.\r\n    Update and insert operations are executed one after the other to avoid mutual blocking.\r\n     */\r\n    await this._storage.getStore('meta').update([meta, this.cedict.metaKey])\r\n    await this._storage.getStore('dictionary').insert(dictionary)\r\n  }\r\n\r\n  /**\r\n   * Loads a single JSON file from a specified URL and decodes it.\r\n   *\r\n   * @param {string} url - A strings that specifies a URL of a JSON file\r\n   * @returns {Promise<object>|Promise<Error>} - A promise that is resolved with a JSON object or\r\n   *          rejected with the error.\r\n   */\r\n  _loadJson (url) {\r\n    return fetch(url).then(response => response.json())\r\n  }\r\n\r\n  static _getResultRecordsCount (resultsObject) {\r\n    return Object.values(resultsObject).flat().length\r\n  }\r\n}\r\n\r\nCedict.errMsgs = {\r\n  CONF_NO_STORAGE: 'Storage tree is missing from a configuration',\r\n  CONF_NO_STORES: 'Stores data is missing from a configuration',\r\n  CONF_NO_DICT: 'Dictionary tree is missing from a configuration',\r\n  CONF_NO_DICT_PRIMARY_IDX: 'A primaryIndex tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PRIMARY_IDX_KEY_PATH: 'A keyPath option of a primaryIndex tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE: 'A volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE_ENABLED: 'enabled option of a volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_VOLATILE_INDEXED: 'indexed option of a volatileStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM: 'A permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM_ENABLED: 'enabled option of a permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DICT_PERM_INDEXED: 'indexed option of a permanentStorage tree of a dictionary is missing from a configuration',\r\n  CONF_NO_DATA: 'Date tree is missing from a configuration',\r\n  CONF_NO_DATA_VER: 'Data version is missing from a configuration',\r\n  CONF_NO_DATA_REV: 'Data revision is missing from a configuration',\r\n  CONF_NO_DATA_REC_COUNT: 'Data records count is missing from a configuration',\r\n  CONF_NO_DATA_URI: 'Data URI is missing from a configuration',\r\n  CONF_NO_DATA_CHUNKS: 'Data chunks are missing from a configuration',\r\n  NOT_READY: 'CEDICT data is not ready',\r\n  BAD_CHAR_FORM: 'Unknown character form'\r\n}\r\n\r\n/*\r\nNames of errors that can be thrown during operations\r\n */\r\nCedict.errNames = {\r\n  SECURITY_ERR: 'SecurityError'\r\n}\r\n","/**\r\n * Character forms that are supported with the current version of the service.\r\n *\r\n * @type {{SIMPLIFIED: string, TRADITIONAL: string}}\r\n */\r\nexport const CedictCharacterForms = {\r\n  SIMPLIFIED: 'simplified',\r\n  TRADITIONAL: 'traditional'\r\n}\r\n","/**\r\n * @module IndexedDbStore\r\n */\r\nimport Store from '@lexisCs/cedict-service/store.js'\r\n\r\n/**\r\n * A configuration object for IndexedDbStore must contain the following information:\r\n *\r\n * @typedef {object} IndexedDbStoreConfig\r\n * @property {string} name - A name of an IndexedDbStore instance.\r\n * @param {object} primaryIndex - An object defining configuration of a primary index.\r\n * @property {string} primaryIndex.keyPath - A name of a prop in an entry object that will serve as primary key.\r\n */\r\n\r\n/** A an IndexedDB store object */\r\nexport default class IndexedDbStore extends Store {\r\n  /**\r\n   * @param {IndexedDbStoreConfig} configuration - Configuration parameters for IndexedDbStore.\r\n   */\r\n  constructor (configuration) {\r\n    super(configuration)\r\n    this._configuration = configuration\r\n    // DB object is not available when store object is created. It must be added later.\r\n    this._db = null\r\n  }\r\n\r\n  /**\r\n   * Called by a super class to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {IndexedDbStoreConfig} configuration - Configuration parameters for IndexedDbStore.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(IndexedDbStore.errMsgs.NO_STORE_NAME)\r\n    if (!configuration.primaryIndex) throw new Error(IndexedDbStore.errMsgs.NO_PRIMARY_INDEX)\r\n    if (\r\n      !configuration.primaryIndex.hasOwnProperty('keyPath') &&\r\n      !configuration.primaryIndex.hasOwnProperty('auto')\r\n    ) throw new Error(IndexedDbStore.errMsgs.NO_PRIMARY_INDEX_PROPS)\r\n  }\r\n\r\n  /**\r\n   * Associates a store with an IndexedDB interface of a database where it is located.\r\n   *\r\n   * @param {IDBDatabase} db - An interface for connecting to IndexedDB.\r\n   * @returns {IndexedDbStore} A self-reference for chaining.\r\n   */\r\n  associateWith (db) {\r\n    this._db = db\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Disassociate a store from IndexedDB. This method is called when client is disconnected from IndexedDB.\r\n   *\r\n   * @returns {IndexedDbStore} A self-reference for chaining.\r\n   */\r\n  dissociate () {\r\n    this._db = null\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Asserts that an IndexedDbStore is associated with a database.\r\n   *\r\n   * @private\r\n   */\r\n  _assertDb () {\r\n    if (!this._db) throw new Error(IndexedDbStore.errMsgs.NO_DB)\r\n  }\r\n\r\n  /**\r\n   * Checks if store has an auto-incremented primary key\r\n   *\r\n   * @returns {boolean} True if primary key is auto-incremented.\r\n   * @private\r\n   */\r\n  get _isAutoPrimaryKey () {\r\n    return this._configuration.primaryIndex.hasOwnProperty('auto') && this._configuration.primaryIndex.auto\r\n  }\r\n\r\n  /**\r\n   * Returns an array of secondary index objects.\r\n   *\r\n   * @returns {object} An array of secondary index objects.\r\n   * @private\r\n   */\r\n  get _secondaryIndexes () {\r\n    return Object.values(this._configuration.indexes)\r\n  }\r\n\r\n  /**\r\n   * Returns an array of names of secondary indexes.\r\n   *\r\n   * @returns {string} An array of names of secondary indexes.\r\n   * @private\r\n   */\r\n  get _secondaryIndexNames () {\r\n    return Object.values(this._configuration.indexes).map(index => index.name)\r\n  }\r\n\r\n  /**\r\n   * Creates a store. Can be run from `onupgradeneeded` callback only.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was created successfully\r\n   *          and is rejected if creation failed.\r\n   */\r\n  create () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      const options = this._configuration.primaryIndex.keyPath ? { keyPath: this._configuration.primaryIndex.keyPath } : undefined\r\n      const store = this._db.createObjectStore(this._configuration.name, options)\r\n      if (this._configuration.indexes) {\r\n        this._secondaryIndexes.forEach(idx => {\r\n          try {\r\n            store.createIndex(idx.name, idx.keyPath, { unique: idx.unique })\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        })\r\n      }\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes all records from the store.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if all records were removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  clear () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      let transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE) // eslint-disable-line prefer-const\r\n      transaction.onerror = (event) => reject(event)\r\n      let objectStore = transaction.objectStore(this._configuration.name) // eslint-disable-line prefer-const\r\n      let clearRequest = objectStore.clear() // eslint-disable-line prefer-const\r\n      clearRequest.onsuccess = () => resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for a single key. If records do not exist, returns an empty array.\r\n   *\r\n   * @param {*} key - A key that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters:\r\n   * @param {string} options.index - If the key provided as a first argument is for a secondary index\r\n   *        then this field must contain a name of a secondary index to use. If this field is not specified,\r\n   *        then records will be retrieved using a primary index.\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  async get (key, options = {}) {\r\n    if (key === undefined) throw new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED)\r\n    return this.getEntries([key], options).then((result) => result[key])\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for one or several keys. If records do not exist, returns an empty array.\r\n   *\r\n   * @param {*|*[]} keys - A key or an array of keys that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters:\r\n   * @param {string} options.index - If the key provided as a first argument is for a secondary index\r\n   *        then this field must contain a name of a secondary index to use. If this field is not specified,\r\n   *        then records will be retrieved using a primary index.\r\n   * @returns {Promise<{key: object[] }>|Promise<Error>} A promise that is resolved with an object. If contains keys\r\n   *          as its properties and values are arrays of records.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getEntries (keys, { index = undefined } = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      if (keys === undefined) reject(new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED))\r\n      if (!Array.isArray(keys)) keys = [keys]\r\n      if (keys.length === 0) reject(new Error(IndexedDbStore.errMsgs.NO_KEYS_PROVIDED))\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      // Create an object with keys as its props\r\n      let result = keys.reduce((accumulator, key) => { accumulator[key] = []; return accumulator }, {}) // eslint-disable-line prefer-const\r\n      /*\r\n      The order of request execution is guaranteed in IndexedDB.\r\n      This means that when the last request is completed all previous requests are done too.\r\n       */\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i]\r\n        let getRequest\r\n        if (index === undefined) {\r\n          // A secondary index is not set, we'll retrieve records by the primary index\r\n          getRequest = store.getAll(IDBKeyRange.only(key))\r\n        } else {\r\n          // Check if secondary index is valid\r\n          if (!this._secondaryIndexNames.includes(index)) throw new Error(IndexedDbStore.errMsgs.MISSING_SECONDARY_INDEX)\r\n          // Use index to retrieve a record\r\n          const dbIndex = store.index(index)\r\n          getRequest = dbIndex.getAll(IDBKeyRange.only(key))\r\n        }\r\n        getRequest.onsuccess = () => {\r\n          result[key] = getRequest.result\r\n          if (i === keys.length - 1) {\r\n            // A last request has been completed\r\n            resolve(result)\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records that exist in the store. If the store is empty returns an empty array.\r\n   *\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if store is empty.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getAllEntries () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n      transaction.onerror = (error) => { reject(error) }\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      const getRequest = store.getAll()\r\n      getRequest.onsuccess = () => {\r\n        const records = getRequest.result\r\n        resolve(records)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Inserts new records into a store. If one or several records already exist in a database\r\n   * it rejects with an error.\r\n   *\r\n   * @param {object|object[]} records - An array of records to insert.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were inserted\r\n   *          successfully and is rejected if insertion failed.\r\n   */\r\n  insert (records) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!records) { resolve() } // Do nothing\r\n      this._assertDb()\r\n      if (!Array.isArray(records)) { records = [records] }\r\n      let transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE) // eslint-disable-line prefer-const\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (event) => reject(event)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      records.forEach(record => {\r\n        let addRequest = store.add(record) // eslint-disable-line prefer-const\r\n        addRequest.onerror = () => {\r\n          if (addRequest.error.name === 'ConstraintError') {\r\n            reject(new Error(IndexedDbStore.errMsgs.DUPLICATE_RECORD))\r\n          }\r\n          reject(addRequest.error)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates records that already exist in a store.\r\n   * If a record given does not exist in a database yet it will be added there.\r\n   * TODO: with what data format does this function is expected to use most?\r\n   *\r\n   * @param {[*, object]|[[*, object]]} keyValRecordsArr - A single item or an array of items\r\n   *        to insert. Each item is an array with record as a first member and key as a second one.\r\n   *        If database does not use external keys (such as auto-incremented ones) the key value\r\n   *        will be ignored and can be omitted.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were updated\r\n   *          successfully and is rejected if operation failed.\r\n   */\r\n  update (keyValRecordsArr) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!keyValRecordsArr) resolve() // Do nothing\r\n      if (!Array.isArray(keyValRecordsArr)) reject(new Error('Records format must be [key,val] or [[key,val]]'))\r\n      if (!Array.isArray(keyValRecordsArr[0])) { keyValRecordsArr = [keyValRecordsArr] }\r\n      this._assertDb()\r\n      const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ_WRITE)\r\n      transaction.oncomplete = () => resolve()\r\n      transaction.onerror = (error) => reject(error)\r\n      const store = transaction.objectStore(this._configuration.name)\r\n      keyValRecordsArr.forEach(record => {\r\n        let addRequest = this._isAutoPrimaryKey ? store.put(record[0], record[1]) : store.put(record[0]) // eslint-disable-line prefer-const\r\n        addRequest.onerror = () => reject(addRequest.error)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns a total number of records in a store.\r\n   *\r\n   * @returns {Promise<number>|Promise<Error>} A promise that is resolved with number of records\r\n   *          in a store and is rejected if operation failed.\r\n   */\r\n  count () {\r\n    return new Promise((resolve, reject) => {\r\n      this._assertDb()\r\n      try {\r\n        const transaction = this._db.transaction(this._configuration.name, IndexedDbStore.accessModes.READ)\r\n        const store = transaction.objectStore(this._configuration.name)\r\n        const countRequest = store.count()\r\n        countRequest.onsuccess = () => { resolve(countRequest.result) }\r\n      } catch (error) {\r\n        reject(error)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nIndexedDbStore.errMsgs = {\r\n  NO_DB: 'Store is not associated with a DB',\r\n  NO_STORE_NAME: 'A store name is missing from a configuration',\r\n  NO_PRIMARY_INDEX: 'A primaryIndex tree is missing from a configuration',\r\n  NO_PRIMARY_INDEX_PROPS: 'A primaryIndex tree must have either a \"keyPath\" or \"auto\" props',\r\n  NO_KEYS_PROVIDED: 'No keys are provided',\r\n  MISSING_SECONDARY_INDEX: 'Specified secondary index does not exist',\r\n  DUPLICATE_RECORD: 'Record already exists'\r\n}\r\n","import { MessagingService, ResponseMessage, WindowIframeDestination as Destination, CedictDestinationConfig } from 'alpheios-messaging'\r\nimport { CedictCharacterForms } from '@lexisCs/cedict-service/constants.js'\r\nimport Cedict from '@lexisCs/cedict-service/cedict.js'\r\nimport CedictConfig from '@lexisCs/configurations/cedict.js'\r\n\r\nconst messagingServiceName = 'CedictRequestListener'\r\nlet cedictData\r\n\r\n/*\r\nNOTE: The request/response format described below is temporary and will change in phase three.\r\nAfter discussion we decided to add more flexibility for the client in specifying what data it wants to get back.\r\n\r\nCEDICT service supports the following requests:\r\ngetWords:\r\n{\r\n  getWords: {\r\n    words: words,\r\n    characterForm: characterForm\r\n  }\r\n}, where:\r\n  getWords is a type of incoming request;\r\n  words contains an array of words to retrieve;\r\n  characterForm specifies a Chinese character form that will be used during lookups.\r\n  If character form is not known, it can be omitted. In that case CEDICT service will\r\n  check records for traditional Chinese first and, if any matches are found, will return it back.\r\n  If nothing is found within a traditional Chinese, it will look in a simplified one.\r\n  Results for only one character form or no results at all, if no matches are found, will be returned.\r\n\r\nResults will be returned in the following format.\r\n\r\nIf any matches are found:\r\n{\r\n    characterForm: {\r\n        word1: [array of records],\r\n        word2: [an empty array if no records are found for this word]\r\n    }\r\n}\r\n\r\nIf no matches are found an empty object will be returned:\r\n{}\r\n\r\nNOTE: fixtures/src/cedict/cedict-fixture.js implements a stub for `getWords` request of CEDICT service.\r\n      If signature and/or business logic of this request is changed, please update the stub accordingly.\r\n\r\nloadData:\r\n{\r\n  loadData: {}\r\n}\r\nThis request starts an initialization of a CEDICT service.\r\nIf service was initialized successfully, an empty success response is returned.\r\nAn error request is returned if initialization failed.\r\n */\r\n\r\nconst messageHandler = async (request, responseFn) => {\r\n  if (request.body.loadData) {\r\n    if (!cedictData.isReady) {\r\n      try {\r\n        await cedictData.init()\r\n        // TODO: A message to ease manual testing. We will probably want to remove it later\r\n        console.log('CEDICT service is ready')\r\n        responseFn(ResponseMessage.Success(request, {}))\r\n      } catch (err) {\r\n        console.error(`Cannot initialize a CEDICT service: ${err.message}`)\r\n        responseFn(ResponseMessage.Error(request, new Error('Initialization error'), ResponseMessage.errorCodes.INITIALIZATION_ERROR))\r\n      }\r\n    } else {\r\n      // Service has already been initialized, return an empty success message\r\n      responseFn(ResponseMessage.Success(request, {}))\r\n    }\r\n  } else if (request.body.getWords) {\r\n    if (!cedictData.isReady) {\r\n      // If data is loaded to IndexedDB already, we can initialize CEDICT fast and respond to the current request\r\n      try {\r\n        const hasData = await cedictData.hasDataLoaded()\r\n        if (hasData) {\r\n          await cedictData.init()\r\n        }\r\n      } catch (error) {\r\n        // Data is not valid or IndexedDB is unavailable. Cannot initialize CEDICT without downloading of data\r\n      }\r\n    }\r\n\r\n    if (!cedictData.isReady) {\r\n      // Data is not loaded or is invalid; send an uninitialized response to the client\r\n      responseFn(ResponseMessage.Error(request, new Error('Uninitialized'), ResponseMessage.errorCodes.SERVICE_UNINITIALIZED))\r\n      return\r\n    }\r\n\r\n    // This is a get words request\r\n    cedictData.getWords(request.body.getWords.words, request.body.getWords.characterForm)\r\n      .then((result) => {\r\n        responseFn(ResponseMessage.Success(request, result))\r\n      }).catch((error) => responseFn(ResponseMessage.Error(request, error, ResponseMessage.errorCodes.INTERNAL_ERROR)))\r\n  } else {\r\n    responseFn(ResponseMessage.Error(request, new Error('Unsupported request'), ResponseMessage.errorCodes.UNKNOWN_REQUEST))\r\n  }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  // eslint-disable-next-line no-unused-vars\r\n  const service = new MessagingService(\r\n    messagingServiceName,\r\n    new Destination({ ...CedictDestinationConfig, commModes: [Destination.commModes.RECEIVE], receiverCB: messageHandler })\r\n  )\r\n\r\n  try {\r\n    cedictData = new Cedict(CedictConfig)\r\n  } catch (error) {\r\n    console.error(error)\r\n  }\r\n})\r\n\r\nexport { CedictDestinationConfig, CedictCharacterForms }\r\n","/**\r\n * @module Storage\r\n */\r\n\r\n/** A base class for data storage. Storage is a container of several stores (e.g. a database with several tables) */\r\nexport default class Storage {\r\n  constructor (configuration) {\r\n    this.constructor._checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n  }\r\n\r\n  /**\r\n   * An internal method to check if the configuration supplied has all the necessary information in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {object} configuration - A JSON like configuration object.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(Storage.errMsgs.CONF_NO_NAME)\r\n    if (!configuration.version) throw new Error(Storage.errMsgs.CONF_NO_VER)\r\n  }\r\n\r\n  /**\r\n   * Create a storage and all the stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all stores were created successfully or is rejected if operations fails.\r\n   */\r\n  create () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Destroys a storage and all the stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if storage\r\n   *          and all stores were destroyed successfully or is rejected if operations fails.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Establishes a connection to the storage. It, if necessary, initializes a storage and stores it contains.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          established successfully or is rejected if connection fails.\r\n   */\r\n  connect () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Disconnects from the storage.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} Returns a promise that is resolved if connection is\r\n   *          closed successfully or is rejected if operations fails.\r\n   */\r\n  disconnect () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns information to verify storage integrity. A set of integrity data is specific for each particular\r\n   * storage type so each storage implementation must define this function on its own.\r\n   *\r\n   * @returns {Promise<{object}>|Promise<Error>}\r\n   *          Returns a promise that is resolved with an object with storage integrity information or is rejected\r\n   *          if storage integrity is broken.\r\n   */\r\n  getIntegrityData () {\r\n    return new Promise((resolve) => {\r\n      resolve({})\r\n    })\r\n  }\r\n}\r\n\r\nStorage.errMsgs = {\r\n  CONF_NO_NAME: 'Storage name is missing from a configuration',\r\n  CONF_NO_VER: 'Storage version is missing from a configuration'\r\n}\r\n","/**\r\n * @module Store\r\n */\r\n\r\n/**\r\n * A configuration object for Store must contain the following information:\r\n *\r\n * @typedef {object} StoreConfig\r\n * @property {string} name - A name of a store.\r\n */\r\n\r\n/** A base class for data stores */\r\nexport default class Store {\r\n  /**\r\n   * @param {StoreConfig} configuration - An object with configuration parameters.\r\n   */\r\n  constructor (configuration) {\r\n    this.constructor._checkConfiguration(configuration)\r\n    this._configuration = configuration\r\n  }\r\n\r\n  /**\r\n   * Called internally to check if the configuration supplied has all the information necessary in it.\r\n   * If configuration is not valid it will throw an error indicating which check failed.\r\n   *\r\n   * @param {StoreConfig} configuration - An object with configuration parameters.\r\n   * @private\r\n   */\r\n  static _checkConfiguration (configuration) {\r\n    if (!configuration.name) throw new Error(Store.errMsgs.CONF_NO_NAME)\r\n  }\r\n\r\n  /**\r\n   * Associates a store with a container where it exists: a remote storage, an IndexedDB, etc.\r\n   *\r\n   * @param {object} storeObject - A store object.\r\n   * @returns {Store} A self-reference for chaining.\r\n   */\r\n  associateWith (storeObject) {\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a store. Can be run from `onupgradeneeded` callback only.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was created successfully\r\n   *          and is rejected if creation failed.\r\n   */\r\n  create () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes all records from the store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if all records were removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  clear () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Deletes a store from its container.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if store was removed successfully\r\n   *          and is rejected if operation failed.\r\n   */\r\n  destroy () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for a single key. Options object is implementation specific.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {*} key - A key that specifies which records to retrieve.\r\n   * @param {object} options - Additional configuration parameters.\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  get (key, options) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records from the store for one or several keys. Options object is implementation specific.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {*|*[]} keys - A key or an array of keys that specifies which records to retrieve.\r\n   * @param {object} [options={}] - Additional configuration parameters.\r\n   * @returns {Promise<{key: object[]}>|Promise<Error>} A promise that is resolved with an object. If contains keys\r\n   *          as its properties and values are arrays of records.\r\n   *          A promise rejection is returned if operation failed.\r\n   */\r\n  getEntries (keys, { index = '' } = {}) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Retrieves all records that exist in the store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<object[]>|Promise<Error>} A promise that is resolved with an array of records if records\r\n   *          exist in a store or with an empty array if not. A promise rejection is returned if operation failed.\r\n   */\r\n  getAllEntries () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Inserts new records into a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {object[]} records - An array of records to insert.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were inserted\r\n   *          successfully and is rejected if insertion failed.\r\n   */\r\n  insert (records) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates records that already exist in a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @param {[any, object]|[[any, object]]} keyValRecordsArr - A single item or an array of items\r\n   *        to insert. Each item is an array with key as a first member and a record to insert as a second one.\r\n   * @returns {Promise<undefined>|Promise<Error>} A promise that is resolved if records were updated\r\n   *          successfully and is rejected if operation failed.\r\n   */\r\n  update (keyValRecordsArr) {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns a total number of records in a store.\r\n   * Must be implemented in a subclass.\r\n   *\r\n   * @returns {Promise<number>|Promise<Error>} A promise that is resolved with number of records\r\n   *          in a store and is rejected if operation failed.\r\n   */\r\n  count () {\r\n    return new Promise((resolve) => {\r\n      resolve()\r\n    })\r\n  }\r\n}\r\n\r\nStore.accessModes = {\r\n  READ: 'readonly',\r\n  READ_WRITE: 'readwrite'\r\n}\r\n\r\nStore.errMsgs = {\r\n  CONF_NO_NAME: 'A store name is missing from a configuration'\r\n}\r\n","/*\r\nThis object defines a configuration of a CEDICT service. We could have several configuration\r\nfiles each targeted for a specific platform or purpose and specify a proper configuration\r\nupon the service initialization.\r\n */\r\nconst cedict = {\r\n  /*\r\n  An information about how CEDICT data is stored within the CEDICT service.\r\n   */\r\n  storage: {\r\n    name: 'cedict',\r\n    /*\r\n    Version defines a configuration of a storage schema, e.g. what tables are used to store data,\r\n    what fields do they have, etc.\r\n     */\r\n    version: 1,\r\n    stores: {\r\n      /*\r\n      A store to keep metadata about a dictionary. It will have only one entry with the metadata object.\r\n       */\r\n      meta: {\r\n        name: 'meta',\r\n        primaryIndex: {\r\n          auto: true\r\n        }\r\n      },\r\n\r\n      /*\r\n      This is a store that keeps dictionary entries themselves.\r\n       */\r\n      dictionary: {\r\n        name: 'dictionary',\r\n        primaryIndex: {\r\n          /*\r\n          What property of a dictionary entry will become a primary index.\r\n           */\r\n          keyPath: 'index'\r\n        },\r\n\r\n        /*\r\n        The following defines the secondary indexes. The name of an index is used to address it\r\n        during queries. keyPath defines what prop of a dictionary entry will be used to build an index.\r\n         */\r\n        indexes: {\r\n          traditional: {\r\n            name: 'traditionalHwIdx',\r\n            keyPath: 'traditional.headword',\r\n            unique: false\r\n          },\r\n          simplified: {\r\n            name: 'simplifiedHwIdx',\r\n            keyPath: 'simplified.headword',\r\n            unique: false\r\n          }\r\n        },\r\n        volatileStorage: {\r\n          /*\r\n          If volatile storage is disabled, all queries will run against an IndexedDB. This will minimize\r\n          RAM usage and is fast enough for most purposes (from several to tens of milliseconds). Enabling\r\n          volatile storage will place data into RAM and data will be retrieved faster at cost of a higher\r\n          RAM usage.\r\n           */\r\n          enabled: false,\r\n\r\n          /*\r\n          If volatile storage is indexed it will create additional in-memory maps to store headword indexes.\r\n          It will result in almost instantaneous retrieval of data at cost of a higher RAM usage.\r\n           */\r\n          indexed: false\r\n        },\r\n        permanentStorage: {\r\n          /*\r\n          With permanents storage enabled all CEDICT data will be saved into an IndexedDB and will stay there\r\n          between page reloads. This will allow not to download all CEDICT data each time the CEDICT service\r\n          is started. It will decrease a service start time significantly (by tens of seconds, usually).It\r\n          will also spare several megabytes of network traffic.\r\n\r\n          With permanent storage enabled clients will be able to run searches directly against an IndexedDB\r\n          thus keeping RAM usage at a minimum.\r\n\r\n          It is highly recommended to have permanent storage always enabled except for cases when\r\n          a target device does not support it.\r\n\r\n          Please note: even if permanent storage is disabled, it will still be created in order to\r\n          put downloaded data into it and to avoid downloading it again with each service initialization.\r\n           */\r\n          enabled: true,\r\n\r\n          /*\r\n          (Currently not implemented.)\r\n          Disabling permanent store indexes will slow searches down significantly (up to more than a second).\r\n          On the other hand, having indexes enabled to not increase IndexedDB size significantly.\r\n          Because of that it is recommended to always have this option on.\r\n           */\r\n          indexed: true\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /*\r\n  Describes CEDICT data on a remote server that is required to run the current version of CEDICT service.\r\n   */\r\n  data: {\r\n    /*\r\n    The date when CEDICT data was last edited.\r\n     */\r\n    version: 20191029,\r\n\r\n    /*\r\n    If data will be updated more than once a day revision will increment with each edition.\r\n     */\r\n    revision: 1,\r\n\r\n    /*\r\n    Number of records in the current CEDICT edition. It is used for integrity checking.\r\n     */\r\n    recordsCount: 117735,\r\n\r\n    /*\r\n    A URI where chunks of CEDICT data are located.\r\n     */\r\n    URI: 'https://lexis-dev.alpheios.net/cedict',\r\n\r\n    /*\r\n    Names of the chunks themselves.\r\n     */\r\n    chunks: [\r\n      'cedict-v20191029-c001.json',\r\n      'cedict-v20191029-c002.json',\r\n      'cedict-v20191029-c003.json',\r\n      'cedict-v20191029-c004.json',\r\n      'cedict-v20191029-c005.json'\r\n    ]\r\n  }\r\n}\r\n\r\nexport default cedict\r\n"],"sourceRoot":""}